This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-02T18:36:05.858Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
astro.config.mjs
notes.md
postcss.config.cjs
public/favicon.svg
README.md
src/components/Card.astro
src/components/ParticleSystem.ts
src/components/Scene.ts
src/css-utils/clamp-generator.js
src/css-utils/tokens-to-tailwind.js
src/env.d.ts
src/layouts/Layout.astro
src/pages/index.astro
src/pages/photos.astro
src/types/global.d.ts
src/utils/AnimationManager.js
src/utils/AppState.js
src/utils/EventHandler.js
src/utils/menuState.js
src/utils/UIManager.js
tailwind.config.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

================
File: astro.config.mjs
================
import { defineConfig } from 'astro/config';
import tailwind from "@astrojs/tailwind";
import partytown from "@astrojs/partytown";
import sitemap from "@astrojs/sitemap";

// https://astro.build/config
export default defineConfig({
  integrations: [tailwind({
    applyBaseStyles: false
  }), partytown(), sitemap()]
});

================
File: notes.md
================
## TO FIX:
- re-running logo animation when comming back from any page
- better motion for typography
- respo

## TO DO:
- /items
- /collections (low priority)
- photo gallery deffinitely to adjust, maybe some extending grid on click - some more brutalism
- better lighting for logo
- better view transitions (must understand the context)

### VERY LOW PRIORITY
- increase logo quality - model 3D
- prepare scenes and backgrounds for some more scenerios

================
File: postcss.config.cjs
================
module.exports = {
  plugins: [
    require('tailwindcss')
  ]
};

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 128 128">
    <path d="M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z" />
    <style>
        path { fill: #000; }
        @media (prefers-color-scheme: dark) {
            path { fill: #FFF; }
        }
    </style>
</svg>

================
File: README.md
================
# Astro CUBE CSS Boilerplate

Based on the [CUBE CSS Boilerplate](https://github.com/Set-Creative-Studio/cube-boilerplate). 

The Astro CUBE CSS Boilerplate is a simple, modern, web platform native starting point with sensible defaults. You get the advantages of modern CSS, with the aid of utility classes, and the affordances of design token architecture. 

Uses:
- [Astro](https://astro.build/), a web framework for content-driven websites
- [Utopia](https://utopia.fyi/), for responsive typography, spacing, and sizing
- [Cube CSS](https://cube.fyi/), a pragmatric and simple CSS methodology
- [Every Layouts](https://every-layout.dev/), better, more resilient CSS
- [Tailwind CSS](https://tailwindcss.com/), a utility-first CSS framework, used as utility-second
- [Partytown](https://partytown.builder.io/), for running third-party scripts in a web worker
- [Astro Sitemap](https://docs.astro.build/en/guides/integrations-guide/sitemap/), for generating a sitemap
- Design tokens, bringing sanity to design decisions.

Read more from Andy Bell's [A CSS project boilerplate
](https://piccalil.li/blog/a-css-project-boilerplate/).

## ðŸ§ž Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

================
File: src/components/Card.astro
================
---
interface Props {
	title: string;
	body: string;
	href: string;
}

const { href, title, body } = Astro.props;
---

<li class="link-card">
	<a href={href}>
		<h2>
			{title}
			<span>&rarr;</span>
		</h2>
		<p>
			{body}
		</p>
	</a>
</li>
<style>
	.link-card {
		list-style: none;
		display: flex;
		padding: 1px;
		background-color: #23262d;
		background-image: none;
		background-size: 400%;
		border-radius: 7px;
		background-position: 100%;
		transition: background-position 0.6s cubic-bezier(0.22, 1, 0.36, 1);
		box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
	}
	.link-card > a {
		width: 100%;
		text-decoration: none;
		line-height: 1.4;
		padding: calc(1.5rem - 1px);
		border-radius: 8px;
		color: white;
		background-color: #23262d;
		opacity: 0.8;
	}
	h2 {
		margin: 0;
		font-size: 1.25rem;
		transition: color 0.6s cubic-bezier(0.22, 1, 0.36, 1);
	}
	p {
		margin-top: 0.5rem;
		margin-bottom: 0;
	}
	.link-card:is(:hover, :focus-within) {
		background-position: 0;
		background-image: var(--accent-gradient);
	}
	.link-card:is(:hover, :focus-within) h2 {
		color: rgb(var(--accent-light));
	}
</style>

================
File: src/components/ParticleSystem.ts
================
// This file can be deleted as we're not using the particle system anymore

================
File: src/components/Scene.ts
================
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import anime from 'animejs/lib/anime.es.js';

// Define distortion shader - keeping the original implementation
const distortionShader = {
    uniforms: {
        "tDiffuse": { value: null },
        "uTime": { value: 0 },
        "uDistortionAmount": { value: 0.0 },
        "uDistortionScale": { value: 10.0 },
        "uMouse": { value: new THREE.Vector2(0.5, 0.5) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uDistortionAmount;
        uniform float uDistortionScale;
        uniform vec2 uMouse;
        varying vec2 vUv;

        void main() {
            // Create distortion effect using sine waves
            vec2 distortion = vec2(
                sin(vUv.y * uDistortionScale + uTime * 0.5) * uDistortionAmount,
                sin(vUv.x * uDistortionScale + uTime * 0.5) * uDistortionAmount
            );

            // Apply mouse influence (interactive)
            float mouseDistance = distance(vUv, uMouse);
            float mouseInfluence = smoothstep(0.5, 0.0, mouseDistance) * 0.05;
            vec2 mouseDistortion = normalize(vUv - uMouse) * mouseInfluence * uDistortionAmount * 5.0;

            // Combine effects
            vec2 distortedUv = vUv + distortion + mouseDistortion;

            // Sample the texture with our distorted coordinates
            vec4 color = texture2D(tDiffuse, distortedUv);

            // Add subtle color aberration
            float aberrationAmount = 0.003 * uDistortionAmount;
            color.r = texture2D(tDiffuse, distortedUv + vec2(aberrationAmount, 0.0)).r;
            color.b = texture2D(tDiffuse, distortedUv - vec2(aberrationAmount, 0.0)).b;

            gl_FragColor = color;
        }
    `
};

/**
 * Helper function to check if we're on the home page
 */
function isHomePage() {
    return window.location.pathname === '/' || window.location.pathname === '';
}

export class Scene {
    private scene: THREE.Scene;
    public camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    public logo: THREE.Group | null = null;
    public isTransitioning: boolean = false;
    private composer: EffectComposer;
    public initialLogoPosition: THREE.Vector3 | null = null;
    public initialLogoRotation: THREE.Euler | null = null;
    private isMenuOpen: boolean = false;
    private mainBeam!: THREE.SpotLight;
    private beamMesh!: THREE.Mesh;
    private secondaryBeamMesh!: THREE.Mesh;
    public distortionPass!: ShaderPass;
    private particles: THREE.Points | null = null;
    private particlesGeometry: THREE.BufferGeometry | null = null;
    private mousePosition: THREE.Vector2 = new THREE.Vector2(0.5, 0.5);
    private clock: THREE.Clock = new THREE.Clock();
    private transitionDirection: 'in' | 'out' = 'in';
    private gridPlane: THREE.Mesh | null = null;
    private cubeCamera: THREE.CubeCamera | null = null;
    private cubeRenderTarget: THREE.WebGLCubeRenderTarget | null = null;

    constructor(container: HTMLElement) {
        console.log("Constructing Scene");

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000000, 0.004); // Balanced fog density

        this.camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        container.appendChild(this.renderer.domElement);

        // Post-processing setup
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // Add bloom effect
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.65,  // Moderate strength
            0.4,   // Moderate radius
            0.85
        );
        this.composer.addPass(bloomPass);

        // Add custom distortion shader
        this.distortionPass = new ShaderPass(distortionShader);
        this.distortionPass.uniforms["uDistortionAmount"].value = 0.0; // Start with no distortion
        this.composer.addPass(this.distortionPass);

        this.setupScene();
        this.setupParticles();
        this.setupGrid();
        this.animate();
        this.handleResize();
        this.setupMouseTracking();
        this.setupMenuNavigation();

        // Register this instance globally for access by other modules
        window.sceneInstance = this;
    }

    /**
     * Setup menu navigation click handling
     */
    private setupMenuNavigation() {
        // Add event listener to all menu items
        const menuItems = document.querySelectorAll('.menu nav ul li a:not(.strike)');
        menuItems.forEach(item => {
            item.addEventListener('click', () => {
                // Animate menu away when navigating
                this.animateMenuAway();
            });
        });
    }

    /**
     * Animate the menu away when navigating
     */
    private animateMenuAway() {
        const menu = document.getElementById('menu');
        if (!menu || !menu.classList.contains('visible')) return;

        // Animate menu items out
        anime({
            targets: '.menu nav ul li',
            translateY: [0, -20],
            opacity: [1, 0],
            duration: 400,
            delay: anime.stagger(50, { direction: 'reverse' }),
            easing: 'easeOutQuad'
        });

        // Then fade out menu
        anime({
            targets: menu,
            opacity: 0,
            duration: 500,
            easing: 'easeOutQuad',
            complete: () => {
                menu.classList.add('hidden');
                menu.classList.remove('visible');
            }
        });
    }

    private setupScene() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        this.mainBeam = new THREE.SpotLight(0xffffff, 120);
        this.mainBeam.position.set(0, 15, 8);
        this.mainBeam.angle = Math.PI / 4.5;
        this.mainBeam.penumbra = 0.4;
        this.mainBeam.decay = 0.9;
        this.mainBeam.distance = 30;
        this.mainBeam.castShadow = true;
        this.scene.add(this.mainBeam);

        const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
        frontLight.position.set(0, 0, 10);
        frontLight.castShadow = false;
        this.scene.add(frontLight);

        const rimLight1 = new THREE.DirectionalLight(0xa0c0ff, 0.5);
        rimLight1.position.set(10, 3, 5);
        this.scene.add(rimLight1);

        const rimLight2 = new THREE.DirectionalLight(0xf0f8ff, 0.5);
        rimLight2.position.set(-10, 3, 5);
        this.scene.add(rimLight2);

        const beamGeometry = new THREE.CylinderGeometry(0.2, 2.5, 15, 32, 1, true);
        const beamMaterial = new THREE.MeshBasicMaterial({
            color: 0x4444ff,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        this.beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
        this.beamMesh.position.copy(this.mainBeam.position);
        this.beamMesh.rotation.x = Math.PI;
        this.scene.add(this.beamMesh);

        this.secondaryBeamMesh = this.beamMesh.clone();
        const secondaryMaterial = beamMaterial.clone();
        secondaryMaterial.opacity = 0.1;
        secondaryMaterial.color.setHex(0x6666ff);
        this.secondaryBeamMesh.material = secondaryMaterial;
        this.secondaryBeamMesh.scale.set(1.8, 1.2, 1.8);
        this.scene.add(this.secondaryBeamMesh);

        this.camera.position.set(0, 1, 12);
        this.camera.lookAt(0, 0, 0);

        const loader = new GLTFLoader();
        const modelPath = '/glass-like-logo-2.glb';
        console.log('Loading model from:', modelPath);

        loader.load(
            modelPath,
            (gltf) => {
                console.log('Model loaded successfully');
                this.logo = gltf.scene;

                const box = new THREE.Box3().setFromObject(this.logo);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 6 / maxDim;
                this.logo.scale.setScalar(scale);

                this.logo.position.sub(center.multiplyScalar(scale));
                this.scene.add(this.logo);

                this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
                this.cubeCamera = new THREE.CubeCamera(1, 1000, this.cubeRenderTarget);
                this.scene.add(this.cubeCamera);

                const envLight = new THREE.HemisphereLight(0xffffff, 0x404040, 0.8);
                this.scene.add(envLight);

                const logoMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xaaccff,
                    metalness: 0.85,
                    roughness: 0.2,
                    reflectivity: 0.8,
                    clearcoat: 0.8,
                    clearcoatRoughness: 0.2,
                    envMap: this.cubeRenderTarget.texture,
                    envMapIntensity: 1.0,
                    emissive: 0x101020,
                    emissiveIntensity: 0.1
                });

                this.logo.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                        child.material = logoMaterial;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                this.initialLogoPosition = this.logo.position.clone();
                this.initialLogoRotation = this.logo.rotation.clone();

                this.hideLoadingScreen();

                // Only show continue prompt on home page
                if (isHomePage()) {
                    this.showContinuePrompt();
                }

                // Create a subtle entrance animation
                this.logo.scale.set(0.01, 0.01, 0.01);
                this.logo.rotation.y = Math.PI * 2;
                anime({
                    targets: this.logo.scale,
                    x: scale,
                    y: scale,
                    z: scale,
                    duration: 1500,
                    easing: 'easeOutElastic(1, 0.5)'
                });
                anime({
                    targets: this.logo.rotation,
                    y: 0,
                    duration: 1500,
                    easing: 'easeOutQuad'
                });
            },
            (progress) => {
                const percentComplete = (progress.loaded / progress.total) * 100;
                console.log('Loading progress:', percentComplete.toFixed(2) + '%');
            },
            (error) => {
                console.error('Error loading model:', error);
                this.hideLoadingScreen();

                // Create a simple fallback cube
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({ color: 0x6666ff, metalness: 0.8 });
                const cube = new THREE.Mesh(geometry, material);
                this.scene.add(cube);
                this.logo = new THREE.Group();
                this.logo.add(cube);
                this.scene.add(this.logo);
                this.initialLogoPosition = this.logo.position.clone();
                this.initialLogoRotation = this.logo.rotation.clone();

                // Only show continue prompt on home page
                if (isHomePage()) {
                    this.showContinuePrompt();
                }
            }
        );
    }

    private setupParticles() {
        const particleCount = 2000;
        this.particlesGeometry = new THREE.BufferGeometry();

        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const opacities = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const radius = 20 + Math.random() * 30;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = radius * Math.cos(phi);

            scales[i] = Math.random() * 0.5 + 0.1;
            opacities[i] = Math.random() * 0.5 + 0.1;
        }

        this.particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.particlesGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        this.particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                attribute float scale;
                attribute float opacity;
                varying float vOpacity;
                uniform float uTime;

                void main() {
                    vec3 pos = position;
                    float offset = position.x + position.y + position.z;
                    pos.x += sin(uTime * 0.2 + offset * 0.1) * 0.5;
                    pos.y += cos(uTime * 0.3 + offset * 0.05) * 0.5;
                    pos.z += sin(uTime * 0.4 + offset * 0.07) * 0.5;

                    vOpacity = opacity * (0.5 + 0.5 * sin(uTime * 0.3 + offset * 0.2));

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = scale * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying float vOpacity;

                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    float alpha = smoothstep(0.5, 0.3, dist) * vOpacity;

                    vec3 color = mix(vec3(0.3, 0.4, 1.0), vec3(0.5, 0.2, 1.0), vOpacity);

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            uniforms: {
                uTime: { value: 0 }
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.particles = new THREE.Points(this.particlesGeometry, particleMaterial);
        this.particles.renderOrder = -1;
        this.scene.add(this.particles);
    }

    private setupGrid() {
        const size = 30;
        const gridGeometry = new THREE.PlaneGeometry(size, size, 32, 32);

        const gridMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                uniform float uTime;
                uniform vec2 uMouse;
                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    vec3 pos = position;
                    float dist = distance(vec2(0.5), uv);
                    float ripple = sin(dist * 10.0 - uTime * 0.5) * 0.2;

                    float mouseStrength = 2.0;
                    float mouseDist = distance(uMouse, uv);
                    float mouseDeformation = smoothstep(0.5, 0.0, mouseDist) * mouseStrength;

                    pos.z += ripple * (1.0 - dist * 2.0);
                    pos.z += mouseDeformation * (1.0 - mouseDist * 2.0);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;

                void main() {
                    vec2 grid = abs(fract(vUv * 15.0 - 0.5) - 0.5) / fwidth(vUv * 15.0);
                    float line = min(grid.x, grid.y);
                    float gridPattern = 1.0 - min(line, 1.0);

                    vec3 baseColor = vec3(0.2, 0.4, 0.8);
                    baseColor += 0.1 * sin(uTime * 0.2 + vUv.x * 5.0) * vec3(0.5, 0.0, 0.5);

                    vec3 finalColor = mix(baseColor * 0.3, baseColor, gridPattern);
                    float alpha = 0.1 + gridPattern * 0.3;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) }
            },
            transparent: true,
            side: THREE.DoubleSide,
            wireframe: false,
            blending: THREE.AdditiveBlending
        });

        this.gridPlane = new THREE.Mesh(gridGeometry, gridMaterial);
        this.gridPlane.position.set(0, -5, 0);
        this.gridPlane.rotation.x = -Math.PI / 2;
        this.gridPlane.receiveShadow = true;
        this.scene.add(this.gridPlane);
    }

    private setupMouseTracking() {
        window.addEventListener('mousemove', (e) => {
            this.mousePosition.x = e.clientX / window.innerWidth;
            this.mousePosition.y = 1 - (e.clientY / window.innerHeight);

            if (this.distortionPass) {
                this.distortionPass.uniforms.uMouse.value = this.mousePosition;
            }

            if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
                this.gridPlane.material.uniforms.uMouse.value = this.mousePosition;
            }
        });
    }

    // Updated handleContinue method for Scene.ts

    public handleContinue() {
        // Check if we can open the menu
        if (this.isMenuOpen || this.isTransitioning) {
            console.log('Cannot handle continue: menu open or transitioning', {
                isMenuOpen: this.isMenuOpen,
                isTransitioning: this.isTransitioning
            });
            return;
        }

        // Only handle continue on home page
        if (!isHomePage()) {
            console.log('Cannot handle continue: not on home page');
            return;
        }

        console.log('Handling continue action - opening menu with animations');
        this.isTransitioning = true;
        const menu = document.getElementById('menu');
        const prompt = document.getElementById('continue-prompt');

        this.isMenuOpen = true;

        // Store current position for our animations
        const currentY = this.logo ? this.logo.position.y : 0;

        // Hide continue prompt with animation
        if (prompt) {
            anime({
                targets: prompt,
                opacity: [1, 0],
                translateY: [0, 30],
                scale: [1, 0.95],
                duration: 600,
                easing: 'easeOutExpo',
                complete: () => prompt.classList.add('hidden')
            });
        }

        // Start distortion effect during menu animation
        if (this.distortionPass) {
            anime({
                targets: this.distortionPass.uniforms.uDistortionAmount,
                value: [0, 0.1, 0],
                duration: 2000,
                easing: 'easeInOutQuad'
            });
        }

        // Only animate logo if it exists
        if (this.logo) {
            const timeline = anime.timeline({
                easing: 'easeInOutQuad'
            });

            timeline
                .add({
                    targets: this.logo.position,
                    y: currentY + 3,
                    duration: 1200,
                    easing: 'easeOutQuad'
                })
                .add({
                    targets: this.logo.rotation,
                    y: Math.PI * 3,
                    duration: 1200,
                    easing: 'easeInOutQuad'
                }, '-=1200')
                .add({
                    targets: this.logo.position,
                    y: currentY - 1,
                    duration: 800,
                    easing: 'easeOutBounce'
                })
                .add({
                    targets: this.logo.rotation,
                    y: Math.PI * 4,
                    duration: 1000,
                    easing: 'easeOutQuad'
                }, '-=800')
                .add({
                    targets: '#continue-prompt',
                    opacity: 0,
                    duration: 300
                }, '-=1000')
                .add({
                    begin: () => {
                        if (menu) {
                            // Ensure menu is visible first
                            menu.classList.remove('hidden');
                            menu.classList.add('visible');

                            // FIXED: Explicitly reset menu item styles
                            const menuItems = menu.querySelectorAll('nav ul li');
                            menuItems.forEach(item => {
                                (item as HTMLElement).style.opacity = '1';
                                (item as HTMLElement).style.transform = 'translateY(0)';
                            });
                        }
                    }
                })
                .add({
                    targets: '.menu nav ul li',
                    translateY: [20, 0],
                    opacity: [0, 1],
                    duration: 600,
                    delay: anime.stagger(80),
                    complete: () => {
                        this.isTransitioning = false;
                        console.log('Menu animation complete, transitioning state:', this.isTransitioning);
                    }
                });
        } else {
            // If no logo, just show the menu
            if (menu) {
                menu.classList.remove('hidden');
                menu.classList.add('visible');

                // FIXED: Explicitly reset menu item styles
                const menuItems = menu.querySelectorAll('nav ul li');
                menuItems.forEach(item => {
                    (item as HTMLElement).style.opacity = '1';
                    (item as HTMLElement).style.transform = 'translateY(0)';
                });
            }

            anime({
                targets: '.menu nav ul li',
                translateY: [20, 0],
                opacity: [0, 1],
                duration: 600,
                delay: anime.stagger(80),
                complete: () => {
                    this.isTransitioning = false;
                }
            });
        }
    }

    // EXPORTED METHOD: Close the menu
    public closeMenu() {
        if (this.isTransitioning) {
            console.log('Cannot close menu: transitioning');
            return;
        }

        if (!this.isMenuOpen) {
            console.log('Cannot close menu: menu not open');
            return;
        }

        this.isTransitioning = true;

        const menu = document.getElementById('menu');

        // Only animate logo if it exists and we're on the home page
        if (this.logo && isHomePage()) {
            const currentY = this.logo.position.y;

            // Add distortion effect when closing menu
            if (this.distortionPass) {
                anime({
                    targets: this.distortionPass.uniforms.uDistortionAmount,
                    value: [0, 0.15, 0],
                    duration: 1500,
                    easing: 'easeInOutQuad'
                });
            }

            const closeTimeline = anime.timeline({
                easing: 'easeInOutQuad'
            });

            closeTimeline
                .add({
                    targets: '.menu nav ul li',
                    translateY: [0, -20],
                    opacity: [1, 0],
                    duration: 400,
                    delay: anime.stagger(50, { direction: 'reverse' })
                })
                .add({
                    targets: '.menu',
                    opacity: 0,
                    duration: 400,
                    complete: () => {
                        if (menu) {
                            menu.classList.add('hidden');
                            menu.classList.remove('visible');
                        }
                    }
                })
                .add({
                    targets: this.logo.position,
                    y: currentY + 2,
                    duration: 800,
                    easing: 'easeOutQuad'
                })
                .add({
                    targets: this.logo.rotation,
                    y: this.initialLogoRotation ? this.initialLogoRotation.y : 0,
                    duration: 1200,
                    easing: 'easeInOutQuad'
                }, '-=800')
                .add({
                    targets: this.logo.position,
                    y: this.initialLogoPosition ? this.initialLogoPosition.y : 0,
                    duration: 1000,
                    easing: 'easeOutElastic(1, 0.8)',
                    complete: () => {
                        this.isTransitioning = false;
                        this.isMenuOpen = false;

                        // Show continue prompt again
                        this.showContinuePrompt();
                        console.log('Menu closed, transitioning state:', this.isTransitioning);
                    }
                });
        } else {
            // Simpler animation if no logo or not on home page
            anime({
                targets: '.menu nav ul li',
                translateY: [0, -20],
                opacity: [1, 0],
                duration: 400,
                delay: anime.stagger(50, { direction: 'reverse' })
            });

            anime({
                targets: '.menu',
                opacity: 0,
                duration: 400,
                complete: () => {
                    if (menu) {
                        menu.classList.add('hidden');
                        menu.classList.remove('visible');
                    }

                    this.isTransitioning = false;
                    this.isMenuOpen = false;

                    // Only show continue prompt on home page
                    if (isHomePage()) {
                        this.showContinuePrompt();
                    }
                }
            });
        }
    }

    private animate = () => {
        requestAnimationFrame(this.animate);

        const time = this.clock.getElapsedTime();

        // Update shader uniforms with time
        if (this.distortionPass) {
            this.distortionPass.uniforms.uTime.value = time;
        }

        // Update particle animation
        if (this.particles && this.particles.material instanceof THREE.ShaderMaterial) {
            this.particles.material.uniforms.uTime.value = time;
        }

        // Update grid animation
        if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
            this.gridPlane.material.uniforms.uTime.value = time;
        }

        if (this.logo) {
            // Apply different animations based on menu state
            if (this.isMenuOpen && !this.isTransitioning) {
                // Menu open animation
                this.logo.rotation.y += 0.0005;
                const pulseIntensity = Math.sin(time * 0.5) * 0.3 + 0.7;
                this.mainBeam.intensity = 120 + (30 * pulseIntensity);
                (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.2 + (0.1 * pulseIntensity);
                (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.15 + (0.05 * pulseIntensity);
                this.scene.fog = new THREE.FogExp2(0x000000, 0.004 + (0.001 * pulseIntensity));

                // Subtle glow animation
                this.logo.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                        child.material.emissiveIntensity = 0.1 + 0.05 * pulseIntensity;
                    }
                });
            } else if (!this.isTransitioning) {
                // Idle state animation
                this.logo.rotation.y += 0.001;
                this.logo.position.y = Math.sin(time * 0.5) * 0.1 + Math.sin(time * 0.2) * 0.03;
                this.logo.rotation.x = Math.sin(time * 0.3) * 0.02;
                this.logo.rotation.z = Math.cos(time * 0.2) * 0.02;

                // Balanced intensity for good visibility
                this.mainBeam.intensity = 100;
                (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.18;
                (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.12;
                this.scene.fog = new THREE.FogExp2(0x000000, 0.004);

                // Very subtle breathing effect
                const breatheIntensity = Math.sin(time * 0.4) * 0.1 + 0.9;
                this.logo.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                        child.material.emissiveIntensity = 0.08 + 0.03 * breatheIntensity;
                    }
                });
            }

            // Update environment map periodically for better reflections
            if (Math.floor(time * 10) % 10 === 0) {
                this.updateLogoEnvMap();
            }
        }

        this.composer.render();
    }

    public prepareForTransition() {
        if (!this.logo) return;

        console.log('Preparing for transition');
        this.isTransitioning = true;

        // Set transition direction based on current state
        if (this.isMenuOpen) {
            this.transitionDirection = 'out';
        } else {
            this.transitionDirection = 'in';
        }

        // Add visual effects during page transitions
        if (this.distortionPass) {
            anime({
                targets: this.distortionPass.uniforms.uDistortionAmount,
                value: [0, 0.2, 0],
                duration: 1000,
                easing: 'easeInOutQuad'
            });
        }

        anime.remove(this.logo.position);
        anime.remove(this.logo.rotation);

        // Page transition animation
        if (this.transitionDirection === 'out') {
            anime({
                targets: this.logo.scale,
                x: this.logo.scale.x * 0.8,
                y: this.logo.scale.y * 0.8,
                z: this.logo.scale.z * 0.8,
                duration: 500,
                easing: 'easeInQuad'
            });

            anime({
                targets: this.logo.position,
                y: this.logo.position.y - 2,
                duration: 500,
                easing: 'easeInQuad'
            });
        } else if (this.logo) {  // Fixed TypeScript null check
            anime({
                targets: this.logo.scale,
                x: this.logo.scale.x * 1.2,
                y: this.logo.scale.y * 1.2,
                z: this.logo.scale.z * 1.2,
                duration: 500,
                easing: 'easeOutQuad',
                complete: () => {
                    if (this.logo) {  // Additional null check for callback
                        anime({
                            targets: this.logo.scale,
                            x: this.logo.scale.x / 1.2,
                            y: this.logo.scale.y / 1.2,
                            z: this.logo.scale.z / 1.2,
                            duration: 800,
                            easing: 'easeOutElastic(1, 0.5)'
                        });
                    }
                }
            });
        }

        // Make sure we reset transition state after animation
        setTimeout(() => {
            this.resetTransitionState();
        }, 800);
    }

    // Just the resetTransitionState method update for Scene.ts

    // Corrected resetTransitionState method for Scene.ts

    public resetTransitionState() {
        console.log('Explicitly resetting transition state from:', this.isTransitioning, 'to false');
        this.isTransitioning = false;

        // Completely reset the menu state if needed
        if (isHomePage()) {
            // On home page, reset menu state
            const menu = document.getElementById('menu');
            if (menu) {
                if (menu.classList.contains('visible')) {
                    this.isMenuOpen = true;
                } else {
                    this.isMenuOpen = false;
                    // Show continue prompt if menu isn't open
                    this.showContinuePrompt();
                }
            }

            // Force event handler reinitialization
            if (window.EventHandler && typeof window.EventHandler.initialize === 'function') {
                console.log('Reinitializing event handlers after navigation');
                window.EventHandler.initialize();
            }
        }
    }

    // A special method to handle returning to the home page from a subpage
    public handleReturnToHome() {
        console.log('Handling return to home page');

        // Reset critical state flags
        this.isTransitioning = false;
        this.isMenuOpen = false;

        // Reset logo position if needed
        if (this.logo && this.initialLogoPosition && this.initialLogoRotation) {
            // Cancel any existing animations
            anime.remove(this.logo.position);
            anime.remove(this.logo.rotation);

            // Reset the logo to its initial state
            this.logo.position.copy(this.initialLogoPosition);
            this.logo.rotation.copy(this.initialLogoRotation);

            // Set balanced lighting values for default state
            this.mainBeam.intensity = 100;
            (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.18;
            (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.12;
            this.scene.fog = new THREE.FogExp2(0x000000, 0.004);
        }

        // Show continue prompt
        this.showContinuePrompt();

        // Force event handler reinitialization
        if (window.EventHandler && typeof window.EventHandler.initialize === 'function') {
            window.EventHandler.initialize();
        }
    }

    private handleResize = () => {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    private updateLogoEnvMap() {
        if (this.logo && this.cubeCamera && this.cubeRenderTarget) {
            // Temporarily hide the logo for environment capture
            this.logo.visible = false;

            // Update the cube camera
            this.cubeCamera.update(this.renderer, this.scene);

            // Make the logo visible again
            this.logo.visible = true;

            // Update the material's environment map for all meshes in the logo
            this.logo.traverse((child) => {
                if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                    child.material.envMap = this.cubeRenderTarget?.texture || null;
                }
            });
        }
    }

    private hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
    }

    private showContinuePrompt() {
        // Only show on home page
        if (!isHomePage()) return;

        const prompt = document.getElementById('continue-prompt');
        if (!prompt) return;

        prompt.classList.remove('hidden');
        const text = prompt.textContent || '';
        prompt.innerHTML = text.split('').map(char =>
            char === ' ' ? ' ' : `<span>${char}</span>`
        ).join('');

        anime.timeline({
            easing: 'easeOutElastic(1, 0.8)'
        })
            .add({
                targets: prompt,
                opacity: 1,
                translateY: [30, 0],
                duration: 800
            })
            .add({
                targets: '#continue-prompt span',
                translateY: [-20, 0],
                opacity: [0, 1],
                delay: anime.stagger(30),
                duration: 600,
                complete: () => {
                    prompt.style.opacity = '1';
                }
            }, '-=400');
    }
}

================
File: src/css-utils/clamp-generator.js
================
const viewports = require('../design-tokens/viewports.json');

/**
 * Takes an array of tokens and sends back and array of name
 * and clamp pairs for CSS fluid values.
 *
 * @param {array} tokens array of {name: string, min: number, max: number}
 * @returns {array} {name: string, value: string}
 */
const clampGenerator = tokens => {
  const rootSize = 16;

  return tokens.map(({name, min, max}) => {
    if (min === max) {
      return `${min / rootSize}rem`;
    }

    // Convert the min and max sizes to rems
    const minSize = min / rootSize;
    const maxSize = max / rootSize;

    // Convert the pixel viewport sizes into rems
    const minViewport = viewports.min / rootSize;
    const maxViewport = viewports.max / rootSize;

    // Slope and intersection allow us to have a fluid value but also keep that sensible
    const slope = (maxSize - minSize) / (maxViewport - minViewport);
    const intersection = -1 * minViewport * slope + minSize;

    return {
      name,
      value: `clamp(${minSize}rem, ${intersection.toFixed(2)}rem + ${(
        slope * 100
      ).toFixed(2)}vw, ${maxSize}rem)`
    };
  });
};

module.exports = clampGenerator;

================
File: src/css-utils/tokens-to-tailwind.js
================
const slugify = require('slugify');

/**
 * Converts human readable tokens into tailwind config friendly ones
 *
 * @param {array} tokens {name: string, value: any}
 * @return {object} {key, value}
 */
const tokensToTailwind = tokens => {
  const nameSlug = text => slugify(text, {lower: true});
  let response = {};

  tokens.forEach(({name, value}) => {
    response[nameSlug(name)] = value;
  });

  return response;
};

module.exports = tokensToTailwind;

================
File: src/env.d.ts
================
/// <reference types="astro/client" />

================
File: src/layouts/Layout.astro
================
---
import "../css/global.css";
import { ClientRouter } from "astro:transitions";
interface Props {
  title: string;
}
const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Thrifted streetwear shop" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap"
      rel="stylesheet"
    />
    <title>{title}</title>
    <ClientRouter />
  </head>
  <body>
    <!-- Loading screen -->
    <div id="loading-screen" transition:persist>
      <div class="loader"></div>
    </div>

    <!-- Three.js scene container -->
    <div id="scene-container" transition:persist>
      <!-- Three.js canvas will be inserted here -->
    </div>

    <!-- Continue prompt -->
    <div id="continue-prompt" class="hidden" transition:persist>
      Press Space or Click Logo to Continue
    </div>

    <!-- Menu overlay -->
    <div id="menu" class="menu hidden" transition:persist>
      <nav>
        <ul>
          <li><a href="#" class="strike">Nowa kolekcja</a></li>
          <li><a href="/photos">ZdjÄ™cia</a></li>
          <li><a href="#posters">Plakaty</a></li>
          <li><a href="#items">Itemy</a></li>
        </ul>
      </nav>
    </div>

    <!-- Page content container -->
    <main id="page-content">
      <slot />
    </main>
    <style>
      #loading-screen {
        position: fixed;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 5px solid #333;
        border-top-color: #fff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      #scene-container {
        position: fixed;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        background: #000;
      }

      #page-content {
        position: relative;
        z-index: 5;
        width: 100%;
        min-height: 100vh;
      }

      #continue-prompt {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: "Rajdhani", sans-serif;
        font-size: 1.4rem;
        font-weight: 500;
        opacity: 0;
        z-index: 100;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        text-shadow:
          0 0 10px rgba(255, 255, 255, 0.5),
          0 0 20px rgba(255, 255, 255, 0.3);
        animation: glowPulse 3s infinite;
        white-space: nowrap;
        transform-origin: center bottom;
        transition: none;
      }

      @keyframes glowPulse {
        0%,
        100% {
          opacity: 0.7;
          transform: translateX(-50%) scale(0.98);
          text-shadow:
            0 0 10px rgba(255, 255, 255, 0.3),
            0 0 20px rgba(255, 255, 255, 0.2);
        }
        50% {
          opacity: 1;
          transform: translateX(-50%) scale(1);
          text-shadow:
            0 0 15px rgba(255, 255, 255, 0.5),
            0 0 30px rgba(255, 255, 255, 0.3),
            0 0 40px rgba(100, 149, 237, 0.3);
        }
      }

      .hidden {
        display: none;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.8);
        opacity: 0;
        transition: opacity 0.5s;
        pointer-events: none;
        z-index: 500;
      }

      .menu.visible {
        opacity: 1;
        pointer-events: all;
      }

      .menu nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
        text-align: center;
      }

      .menu nav ul li {
        margin: 2rem 0;
        transform: translateY(20px);
        opacity: 0;
        transition: all 0.3s;
      }

      .menu.visible nav ul li {
        transform: translateY(0);
        opacity: 1;
      }

      .menu nav ul li a {
        font-family: "Rajdhani", sans-serif;
        font-weight: 700;
        letter-spacing: 0.1em;
        color: white;
        text-decoration: none;
        font-size: 2rem;
        transition: color 0.3s;
      }

      .menu nav ul li a:hover {
        color: #f0f0f0;
      }

      .menu nav ul li a.strike {
        text-decoration: line-through;
        opacity: 0.5;
        pointer-events: none;
      }
    </style>

    <script>
      import { EventHandler } from "../utils/EventHandler";
      import { Scene } from "../components/Scene";

      // Ensure we have a global type declaration for sceneInstance
      if (typeof window !== "undefined") {
        window.sceneInstance = window.sceneInstance || null;
        window.navBackToHome = window.navBackToHome || false;
      }

      // Initialize the scene and event handlers
      document.addEventListener("DOMContentLoaded", () => {
        console.log("DOM ready, initializing scene and handlers");

        // Initialize scene first
        initScene();

        // Then set up event handlers
        if (typeof EventHandler.initialize === "function") {
          EventHandler.initialize();
        }
      });

      // Create the 3D scene
      function initScene() {
        const container = document.getElementById("scene-container");
        if (container && !document.querySelector("#scene-container canvas")) {
          console.log("Creating new Scene instance");
          new Scene(container); // Scene registers itself as window.sceneInstance
        }
      }

      // Handle page transitions
      document.addEventListener("astro:before-navigation", () => {
        // Prepare scene for transition
        if (
          window.sceneInstance &&
          typeof window.sceneInstance.prepareForTransition === "function"
        ) {
          window.sceneInstance.prepareForTransition();
        }
      });

      document.addEventListener("astro:after-navigation", () => {
        // Check if we navigated back to home from a subpage
        const isBackToHome =
          window.navBackToHome &&
          (window.location.pathname === "/" || window.location.pathname === "");

        if (isBackToHome && window.sceneInstance) {
          // Use the special back-to-home handler
          if (typeof window.sceneInstance.handleReturnToHome === "function") {
            window.sceneInstance.handleReturnToHome();
          } else {
            // Fallback to regular reset
            window.sceneInstance.resetTransitionState();
          }

          // Reset the flag
          window.navBackToHome = false;
        } else if (window.sceneInstance) {
          // Regular navigation reset
          window.sceneInstance.resetTransitionState();
        }
      });

      document.addEventListener("astro:page-load", () => {
        console.log("Page fully loaded, ensuring handlers are active");

        const isHomePage =
          window.location.pathname === "/" || window.location.pathname === "";

        // Always reinitialize event handlers after page load
        if (typeof EventHandler.initialize === "function") {
          EventHandler.initialize();
        }

        // Force a final state reset on the scene
        if (window.sceneInstance) {
          if (isHomePage) {
            console.log("Home page loaded - ensuring proper state");

            // Make sure event handlers are active
            setTimeout(() => {
              if (typeof EventHandler.initialize === "function") {
                EventHandler.initialize();
              }

              // Make sure scene is ready for interaction
              if (window.sceneInstance) {
                window.sceneInstance.resetTransitionState();
              }
            }, 100);
          }
        }
      });
    </script>
  </body>
</html>

================
File: src/pages/index.astro
================
---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Thrifted streetwear shop">
  <div class="home-content"></div>
</Layout>

<script>
  import { AppState } from "../utils/AppState";
  import { EventHandler } from "../utils/EventHandler";

  document.addEventListener("DOMContentLoaded", () => {
    // Make sure global scene instance is accessible
    if (typeof window !== 'undefined' && window.sceneInstance) {
      // Already assigned in Scene constructor
    }
    
    // Initialize back button handling
    EventHandler.initializeBackButton();
    
    // Ensure we're in the correct state on the home page
    if (AppState.isHomePage()) {
      // Reset any stored transition state
      AppState.resetSceneTransitionState();
    }
  });
</script>

<style>
  .home-content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    color: white;
    text-align: center;
    padding: 2rem;
    opacity: 0;
    transition: opacity 0.5s ease;
  }

  :global(#menu.visible) ~ .home-content {
    opacity: 1;
  }

  h1 {
    font-family: "Rajdhani", sans-serif;
    font-size: 3rem;
    font-weight: 700;
    margin-bottom: 1rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    text-shadow:
      0 0 15px rgba(255, 255, 255, 0.3),
      0 0 30px rgba(100, 149, 237, 0.3);
  }

  p {
    font-family: "Outfit", sans-serif;
    font-size: 1.2rem;
    max-width: 600px;
    margin: 0 auto;
  }
</style>

================
File: src/pages/photos.astro
================
---
import Layout from '../layouts/Layout.astro';
---
<Layout title="Photos | Thrifted streetwear shop">
  <div class="photos-container">
    <div class="photos-header">
      <h1>Photo Gallery</h1>
      <a href="/" class="back-button" id="back-to-home">Back to Home</a>
    </div>

    <div class="photos-grid">
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149569710.jpg?t=st=1740863882~exp=1740867482~hmac=6e3d92db1518edc3a4d0b5b5a35aa3a7a19ed441fa85dab3d2affb7697539349&w=740" alt="Fantasy cards" />
        <div class="photo-caption">Fantasy Collection</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149587976.jpg?t=st=1740862298~exp=1740865898~hmac=b864d9a601321fc767eee479f266893401ee4d2df748a8a0b8099b64be36fe39&w=740" alt="Card game" />
        <div class="photo-caption">Tournament Series</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/abstract-female-portrait-made-different-shapes_23-2149126821.jpg?t=st=1740863207~exp=1740866807~hmac=76d19808c0afa3df81c0741231ff6f09b45eecbe73caaf3082dbbfcf4cd3bbcb&w=740" alt="Trading cards" />
        <div class="photo-caption">Limited Edition</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-picasso-style-illustration_23-2149602595.jpg?t=st=1740863890~exp=1740867490~hmac=019c3c6037c207bf001290e43da83e06b5ab075fb1f38c8357923e6b554552ac&w=1060" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-flat-abstract-shapes-collection_23-2149085348.jpg?t=st=1740863893~exp=1740867493~hmac=3719b5d78cd491929bc8275ed968419491b209f122ea53f33820c04f90e1c489&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/flat-design-geometric-pattern-illustration_23-2150010041.jpg?t=st=1740863897~exp=1740867497~hmac=71cd7c54211a7809daec097a498c20e1aa307b794959936f53e99964f678c3bc&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
    </div>
  </div>
</Layout>

<script>
import { AppState } from '../utils/AppState';
import { EventHandler } from '../utils/EventHandler';

document.addEventListener('DOMContentLoaded', () => {
  // Initialize back button handling
  EventHandler.initializeBackButton();
  
  // Set correct app state for subpage
  if (!AppState.isHomePage()) {
    AppState.transitionTo('SUBPAGE');
  }
});
</script>

<style>
  .photos-container {
    position: relative;
    z-index: 10;
    padding: 4rem 2rem;
    color: white;
    max-width: 1200px;
    margin: 0 auto;
    opacity: 0;
    animation: fadeIn 0.8s forwards;
    animation-delay: 0.3s;
  }

  .photos-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 3rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  h1 {
    font-family: 'Rajdhani', sans-serif;
    font-size: 3rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    text-shadow: 0 0 15px rgba(255,255,255,0.3),
                 0 0 30px rgba(100,149,237,0.3);
    margin: 0;
  }

  .back-button {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: white;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 0.6rem 1.2rem;
    border-radius: 4px;
    text-decoration: none;
    transition: all 0.3s ease;
  }

  .back-button:hover {
    background: rgba(100, 149, 237, 0.2);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }

  .photos-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
  }

  .photo-item {
    position: relative;
    aspect-ratio: 4/3;
    overflow: hidden;
    border-radius: 8px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
  }

  .photo-item:hover {
    transform: scale(1.02) translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
  }

  .photo-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.3s ease, transform 0.5s ease;
  }

  .photo-item:hover img {
    opacity: 0.9;
    transform: scale(1.05);
  }

  .photo-caption {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-family: 'Outfit', sans-serif;
    font-weight: 500;
    transform: translateY(100%);
    transition: transform 0.3s ease;
  }

  .photo-item:hover .photo-caption {
    transform: translateY(0);
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @media (max-width: 768px) {
    .photos-header {
      flex-direction: column;
      align-items: flex-start;
    }

    h1 {
      font-size: 2.2rem;
    }

    .photos-grid {
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 1.5rem;
    }
  }
</style>

================
File: src/types/global.d.ts
================
/**
 * Global type declarations for the application
 */

interface Window {
    sceneInstance: any;
    navBackToHome: boolean;
    EventHandler?: any;
  }

================
File: src/utils/AnimationManager.js
================
/**
 * AnimationManager.js
 * Centralized animation management for the application
 */

import anime from 'animejs/lib/anime.es.js';

class AnimationManagerClass {
  constructor() {
    // Track active animations for cleanup
    this._activeAnimations = [];
  }
  
  /**
   * Clear all active animations to prevent conflicts
   */
  clearAnimations() {
    console.log(`[AnimationManager] Clearing ${this._activeAnimations.length} active animations`);
    
    this._activeAnimations.forEach(anim => {
      if (anim && typeof anim.pause === 'function') {
        anim.pause();
      }
    });
    
    this._activeAnimations = [];
  }
  
  /**
   * Animate the 3D logo for menu opening
   */
  animateLogoForMenuOpen(logo, onComplete) {
    if (!logo) return;
    
    console.log('[AnimationManager] Animating logo for menu open');
    this.clearAnimations();
    
    // Store current position for reference
    const currentY = logo.position.y;
    
    // Start distortion effect during menu animation
    this.animateDistortionEffect(0.1, 2000);
    
    // Create animation timeline for coordinated effects
    const timeline = anime.timeline({
      easing: 'easeInOutQuad'
    });
    
    timeline
      .add({
        targets: logo.position,
        y: currentY + 3,
        duration: 1200,
        easing: 'easeOutQuad'
      })
      .add({
        targets: logo.rotation,
        y: Math.PI * 3,
        duration: 1200,
        easing: 'easeInOutQuad'
      }, '-=1200')
      .add({
        targets: logo.position,
        y: currentY - 1,
        duration: 800,
        easing: 'easeOutBounce'
      })
      .add({
        targets: logo.rotation,
        y: Math.PI * 4,
        duration: 1000,
        easing: 'easeOutQuad',
        complete: () => {
          if (onComplete) onComplete();
        }
      }, '-=800');
    
    this._activeAnimations.push(timeline);
  }
  
  /**
   * Animate the 3D logo for menu closing
   */
  animateLogoForMenuClose(logo, onComplete) {
    if (!logo) return;
    
    console.log('[AnimationManager] Animating logo for menu close');
    this.clearAnimations();
    
    // Get initial position for reference (should have been saved on open)
    const currentY = logo.position.y;
    const initialY = logo.initialLogoPosition?.y || 0;
    const initialRotationY = logo.initialLogoRotation?.y || 0;
    
    // Add distortion effect when closing menu
    this.animateDistortionEffect(0.15, 1500);
    
    // Create animation timeline
    const closeTimeline = anime.timeline({
      easing: 'easeInOutQuad'
    });
    
    closeTimeline
      .add({
        targets: logo.position,
        y: currentY + 2,
        duration: 800,
        easing: 'easeOutQuad'
      })
      .add({
        targets: logo.rotation,
        y: initialRotationY,
        duration: 1200,
        easing: 'easeInOutQuad'
      }, '-=800')
      .add({
        targets: logo.position,
        y: initialY,
        duration: 1000,
        easing: 'easeOutElastic(1, 0.8)',
        complete: () => {
          if (onComplete) onComplete();
        }
      });
    
    this._activeAnimations.push(closeTimeline);
  }
  
  /**
   * Animate distortion effect for transitions
   */
  animateDistortionEffect(amount, duration) {
    // Find the scene instance to access uniforms
    const sceneInstance = window.sceneInstance;
    
    if (sceneInstance && sceneInstance.distortionPass) {
      console.log(`[AnimationManager] Animating distortion effect: ${amount}`);
      
      const distortionAnim = anime({
        targets: sceneInstance.distortionPass.uniforms.uDistortionAmount,
        value: [0, amount, 0],
        duration: duration,
        easing: 'easeInOutQuad'
      });
      
      this._activeAnimations.push(distortionAnim);
    }
  }
  
  /**
   * Animate the logo for page transitions
   */
  animateLogoForPageTransition(logo, direction) {
    if (!logo) return;
    
    console.log(`[AnimationManager] Animating logo for page transition: ${direction}`);
    this.clearAnimations();
    
    // Apply distortion effect during transitions
    this.animateDistortionEffect(0.2, 1000);
    
    // Clear any existing position/rotation animations
    anime.remove(logo.position);
    anime.remove(logo.rotation);
    
    // Different animations based on direction
    if (direction === 'out') {
      // Scaling down and moving down when leaving
      anime({
        targets: logo.scale,
        x: logo.scale.x * 0.8,
        y: logo.scale.y * 0.8,
        z: logo.scale.z * 0.8,
        duration: 500,
        easing: 'easeInQuad'
      });
      
      anime({
        targets: logo.position,
        y: logo.position.y - 2,
        duration: 500,
        easing: 'easeInQuad'
      });
    } else {
      // Scaling up and bouncing when entering
      anime({
        targets: logo.scale,
        x: logo.scale.x * 1.2,
        y: logo.scale.y * 1.2,
        z: logo.scale.z * 1.2,
        duration: 500,
        easing: 'easeOutQuad',
        complete: () => {
          anime({
            targets: logo.scale,
            x: logo.scale.x / 1.2,
            y: logo.scale.y / 1.2,
            z: logo.scale.z / 1.2,
            duration: 800,
            easing: 'easeOutElastic(1, 0.5)'
          });
        }
      });
    }
  }
}

// Export a singleton instance
export const AnimationManager = new AnimationManagerClass();

================
File: src/utils/AppState.js
================
/**
 * AppState.js
 * Centralized state management for the entire application
 */

import { UIManager } from './UIManager';
import { AnimationManager } from './AnimationManager';

// Ensure correct typing for the global Scene instance
if (typeof window !== 'undefined') {
  window.sceneInstance = window.sceneInstance || null;
}

class AppStateManager {
  constructor() {
    this._currentState = 'INITIALIZING';
    this._previousState = null;
    this._lastStateChangeTime = 0;
    this._navigationBackToHome = false;
    this._stateDebounceTime = 300; // ms to prevent rapid state changes
  }
  
  /**
   * Get the current application state
   */
  get currentState() {
    return this._currentState;
  }
  
  /**
   * Check if we're currently transitioning between states
   */
  get isTransitioning() {
    return ['MENU_OPENING', 'MENU_CLOSING', 'TRANSITIONING_TO_SUBPAGE', 'TRANSITIONING_TO_HOME'].includes(this._currentState);
  }
  
  /**
   * Get the scene instance if available
   */
  get sceneInstance() {
    return window.sceneInstance || null;
  }
  
  /**
   * Initialize the AppState with the correct initial state based on URL
   */
  initialize() {
    // Determine initial state based on URL
    const isHomePage = this.isHomePage();
    
    if (isHomePage) {
      this._currentState = 'INITIALIZING';
    } else {
      this._currentState = 'SUBPAGE';
    }
    
    console.log(`[AppState] Initialized with state: ${this._currentState}`);
    
    // Listen for Astro page transitions
    document.addEventListener('astro:before-preparation', this.handleBeforePreparation.bind(this));
    document.addEventListener('astro:before-navigation', this.handleBeforeNavigation.bind(this));
    document.addEventListener('astro:after-navigation', this.handleAfterNavigation.bind(this));
    document.addEventListener('astro:page-load', this.handlePageLoad.bind(this));
  }
  
  /**
   * Transition to a new state with appropriate actions
   */
  transitionTo(newState) {
    // Prevent rapid state changes
    const now = Date.now();
    if (now - this._lastStateChangeTime < this._stateDebounceTime) {
      console.log(`[AppState] State transition debounced: ${this._currentState} â†’ ${newState}`);
      return false;
    }
    
    console.log(`[AppState] State transition: ${this._currentState} â†’ ${newState}`);
    this._previousState = this._currentState;
    this._currentState = newState;
    this._lastStateChangeTime = now;
    
    // Perform state-specific actions
    this.performStateActions(newState);
    
    // Dispatch state change event
    document.dispatchEvent(new CustomEvent('appStateChanged', { 
      detail: { 
        newState,
        previousState: this._previousState 
      }
    }));
    
    return true;
  }
  
  /**
   * Check if we're on the home page
   */
  isHomePage() {
    return window.location.pathname === '/' || window.location.pathname === '';
  }
  
  /**
   * Check if menu interaction is allowed
   */
  isMenuInteractionAllowed() {
    return this.isHomePage() && !this.isTransitioning;
  }
  
  /**
   * Flag that we're navigating back to home
   */
  setNavigatingBackToHome(value) {
    this._navigationBackToHome = value;
    console.log(`[AppState] Navigating back to home: ${value}`);
  }
  
  /**
   * Check if we're navigating back to home
   */
  isNavigatingBackToHome() {
    return this._navigationBackToHome;
  }
  
  /**
   * Reset transition state in the 3D scene
   */
  resetSceneTransitionState() {
    if (this.sceneInstance && typeof this.sceneInstance.resetTransitionState === 'function') {
      console.log('[AppState] Resetting scene transition state');
      this.sceneInstance.resetTransitionState();
    }
  }
  
  /**
   * Open the menu with animations
   */
  openMenu() {
    if (!this.isMenuInteractionAllowed()) {
      console.log('[AppState] Menu interaction not allowed');
      return;
    }
    
    if (this._currentState === 'IDLE') {
      this.transitionTo('MENU_OPENING');
      
      // Start menu opening animations
      UIManager.showMenu();
      if (this.sceneInstance && this.sceneInstance.logo) {
        AnimationManager.animateLogoForMenuOpen(this.sceneInstance.logo, () => {
          this.transitionTo('MENU_OPEN');
        });
      } else {
        // If no scene instance, still transition to MENU_OPEN
        setTimeout(() => this.transitionTo('MENU_OPEN'), 1000);
      }
    }
  }
  
  /**
   * Close the menu with animations
   */
  closeMenu() {
    if (this._currentState === 'MENU_OPEN') {
      this.transitionTo('MENU_CLOSING');
      
      // Start menu closing animations
      UIManager.hideMenu();
      if (this.sceneInstance && this.sceneInstance.logo) {
        AnimationManager.animateLogoForMenuClose(this.sceneInstance.logo, () => {
          this.transitionTo('IDLE');
        });
      } else {
        // If no scene instance, still transition to IDLE
        setTimeout(() => this.transitionTo('IDLE'), 1000);
      }
    }
  }
  
  /**
   * Prepare for transition between pages
   */
  prepareForTransition(toHomePage) {
    if (toHomePage) {
      this.transitionTo('TRANSITIONING_TO_HOME');
      this.setNavigatingBackToHome(true);
    } else {
      this.transitionTo('TRANSITIONING_TO_SUBPAGE');
    }
    
    // Prepare the scene for transition
    if (this.sceneInstance && typeof this.sceneInstance.prepareForTransition === 'function') {
      this.sceneInstance.prepareForTransition();
    }
  }
  
  /**
   * Handle actions specific to each state
   */
  performStateActions(state) {
    switch (state) {
      case 'INITIALIZING':
        // Show loading screen (already visible by default)
        break;
        
      case 'IDLE':
        // Show continue prompt, hide menu
        UIManager.showContinuePrompt();
        UIManager.ensureMenuHidden();
        break;
        
      case 'MENU_OPEN':
        // Hide continue prompt, show menu
        UIManager.hideContinuePrompt();
        UIManager.ensureMenuVisible();
        break;
        
      case 'MENU_CLOSING':
        // Menu closing animation handled by AnimationManager
        break;
        
      case 'MENU_OPENING':
        // Menu opening animation handled by AnimationManager
        break;
        
      case 'TRANSITIONING_TO_SUBPAGE':
        // Prepare scene for transition, handled elsewhere
        break;
        
      case 'TRANSITIONING_TO_HOME':
        // Prepare scene for transition, handled elsewhere
        break;
        
      case 'SUBPAGE':
        // Hide continue prompt, ensure menu is hidden
        UIManager.hideContinuePrompt();
        UIManager.ensureMenuHidden();
        break;
    }
  }
  
  /**
   * Event Handlers for Astro page transitions
   */
  handleBeforePreparation(e) {
    console.log('[AppState] Before preparation, navigating to:', e.to);
    
    // Detect if we're navigating to home
    const isNavigatingToHome = e.to === '/' || e.to.endsWith('/');
    const isLeavingHomePage = this.isHomePage();
    
    if (isNavigatingToHome && !isLeavingHomePage) {
      this.prepareForTransition(true);
    } else if (isLeavingHomePage) {
      this.prepareForTransition(false);
    }
  }
  
  handleBeforeNavigation(e) {
    console.log('[AppState] Before navigation');
    
    // Additional preparation before navigation starts
    if (this.isTransitioning) {
      // Make sure any animations are in a stable state
      AnimationManager.clearAnimations();
    }
  }
  
  handleAfterNavigation() {
    console.log('[AppState] After navigation');
    
    // Update state based on new URL
    if (this.isHomePage()) {
      // Reset scene state when arriving at home
      this.resetSceneTransitionState();
      
      // If we came from a subpage, ensure we're in IDLE state
      if (this._currentState === 'TRANSITIONING_TO_HOME') {
        this.transitionTo('IDLE');
      }
    } else {
      // We're on a subpage
      this.transitionTo('SUBPAGE');
    }
  }
  
  handlePageLoad() {
    console.log('[AppState] Page load');
    
    if (this.isHomePage()) {
      // Make sure scene is in the right state
      this.resetSceneTransitionState();
      
      // Check if we navigated back to home
      if (this.isNavigatingBackToHome()) {
        this.setNavigatingBackToHome(false);
        this.transitionTo('IDLE');
        UIManager.enforceCorrectUIState();
      }
    }
  }
}

// Export a singleton instance
export const AppState = new AppStateManager();

================
File: src/utils/EventHandler.js
================
/**
 * EventHandler.js
 * Fixed to ensure proper re-initialization after navigation
 */

import * as THREE from 'three';

// Simple helper function to check if we're on the home page
function isHomePage() {
  return window.location.pathname === '/' || window.location.pathname === '';
}

class EventHandlerClass {
  constructor() {
    this._initialized = false;
    this._boundHandlers = {
      keydown: null,
      click: null,
      menuBgClick: null,
      escape: null
    };
    
    // Make this instance globally available
    if (typeof window !== 'undefined') {
      window.EventHandler = this;
    }
  }
  
  /**
   * Initialize all event listeners
   */
  initialize() {
    // Prevent double initialization
    if (this._initialized) {
      this.cleanup(); // Remove existing handlers first
    }
    
    console.log('[EventHandler] Initializing event handlers');
    this._initialized = true;
    
    // Bind methods to maintain 'this' context
    this._boundHandlers.keydown = this.handleKeyDown.bind(this);
    this._boundHandlers.click = this.handleLogoClick.bind(this);
    this._boundHandlers.menuBgClick = this.handleMenuBackgroundClick.bind(this);
    this._boundHandlers.escape = this.handleEscapeKey.bind(this);
    
    // Add global event listeners for keyboard
    document.addEventListener('keydown', this._boundHandlers.keydown);
    
    // Add escape key handler
    document.addEventListener('keydown', this._boundHandlers.escape);
    
    // Set up scene click detection for logo
    const sceneContainer = document.getElementById('scene-container');
    if (sceneContainer) {
      sceneContainer.addEventListener('click', this._boundHandlers.click);
    }
    
    // Handle menu background clicks
    const menu = document.getElementById('menu');
    if (menu) {
      menu.addEventListener('click', this._boundHandlers.menuBgClick);
    }
    
    // Initialize back button
    this.initializeBackButton();
    
    // Handle navigation transitions for menu items
    this.setupMenuNavigationHandling();
    
    console.log('[EventHandler] Event handlers initialized');
  }
  
  /**
   * Set up handlers for menu item clicks
   */
  setupMenuNavigationHandling() {
    // Add event listeners to menu items
    const menuLinks = document.querySelectorAll('.menu nav ul li a:not(.strike)');
    menuLinks.forEach((link) => {
      link.addEventListener('click', () => {
        if (window.sceneInstance && typeof window.sceneInstance.animateMenuAway === 'function') {
          window.sceneInstance.animateMenuAway();
        }
      });
    });
  }
  
  /**
   * Clean up all event listeners
   */
  cleanup() {
    console.log('[EventHandler] Cleaning up event handlers');
    
    if (this._boundHandlers.keydown) {
      document.removeEventListener('keydown', this._boundHandlers.keydown);
    }
    
    if (this._boundHandlers.escape) {
      document.removeEventListener('keydown', this._boundHandlers.escape);
    }
    
    const sceneContainer = document.getElementById('scene-container');
    if (sceneContainer && this._boundHandlers.click) {
      sceneContainer.removeEventListener('click', this._boundHandlers.click);
    }
    
    const menu = document.getElementById('menu');
    if (menu && this._boundHandlers.menuBgClick) {
      menu.removeEventListener('click', this._boundHandlers.menuBgClick);
    }
    
    // Reset bound handlers
    this._boundHandlers = {
      keydown: null,
      click: null,
      menuBgClick: null,
      escape: null
    };
    
    this._initialized = false;
  }
  
  /**
   * Handle space key press
   */
  handleKeyDown(e) {
    if (e.code === 'Space' && isHomePage()) {
      console.log('[EventHandler] Space key pressed, handling continue');
      if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
        window.sceneInstance.handleContinue();
      } else {
        console.error('[EventHandler] SceneInstance or handleContinue not available');
      }
      
      // Prevent space from scrolling the page
      e.preventDefault();
    }
  }
  
  /**
   * Handle logo clicks via raycasting
   */
  handleLogoClick(e) {
    if (!isHomePage()) return;
    
    const scene = window.sceneInstance;
    if (!scene || !scene.logo || !scene.camera) {
      console.log('[EventHandler] Scene not ready for logo detection');
      return;
    }
    
    console.log('[EventHandler] Scene click detected, checking logo intersection');
    
    // Set up raycaster for logo detection
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(
      (e.clientX / window.innerWidth) * 2 - 1,
      -(e.clientY / window.innerHeight) * 2 + 1
    );
    
    raycaster.setFromCamera(mouse, scene.camera);
    const intersects = raycaster.intersectObject(scene.logo, true);
    
    if (intersects.length > 0) {
      console.log('[EventHandler] Logo click detected');
      scene.handleContinue();
    }
  }
  
  /**
   * Handle menu background clicks to close menu
   */
  handleMenuBackgroundClick(e) {
    if (e.target === e.currentTarget) { // Only if clicked directly on menu bg, not its children
      console.log('[EventHandler] Menu background click detected');
      if (window.sceneInstance && typeof window.sceneInstance.closeMenu === 'function') {
        window.sceneInstance.closeMenu();
      }
    }
  }
  
  /**
   * Handle escape key to close menu
   */
  handleEscapeKey(e) {
    if (e.code === 'Escape') {
      console.log('[EventHandler] Escape key pressed');
      if (window.sceneInstance && typeof window.sceneInstance.closeMenu === 'function') {
        window.sceneInstance.closeMenu();
      }
    }
  }
  
  /**
   * Initialize back button
   */
  initializeBackButton() {
    const backButton = document.getElementById('back-to-home');
    if (backButton) {
      console.log('[EventHandler] Initializing back button');
      
      // Remove existing click listeners to prevent duplicates
      const newBackButton = backButton.cloneNode(true);
      if (backButton.parentNode) {
        backButton.parentNode.replaceChild(newBackButton, backButton);
      }
      
      newBackButton.addEventListener('click', (e) => {
        // If already on home page, just trigger menu
        if (isHomePage()) {
          e.preventDefault();
          if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
            window.sceneInstance.handleContinue();
          }
        } else {
          // On subpage, apply transition effect
          this.triggerCustomTransition();
          window.navBackToHome = true;
        }
      });
    }
  }
  
  /**
   * Create a custom transition overlay effect
   */
  triggerCustomTransition() {
    console.log('[EventHandler] Triggering custom transition effect');
    
    // Create overlay element
    const overlay = document.createElement('div');
    overlay.classList.add('page-transition-overlay');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
    `;
    
    document.body.appendChild(overlay);
    
    // Fade in overlay
    requestAnimationFrame(() => {
      overlay.style.opacity = '0.8';
    });
    
    // Clean up overlay after navigation
    setTimeout(() => {
      overlay.remove();
    }, 800);
  }
}

// Export a singleton instance
export const EventHandler = new EventHandlerClass();

================
File: src/utils/menuState.js
================
/**
 * menuState.js - Compatibility Layer
 * 
 * This version preserves the old API while adding compatibility with the new system
 */

// Ensure we have the global navigation flag
if (typeof window !== 'undefined') {
  window.navBackToHome = window.navBackToHome || false;
}

/**
 * Checks if current page is a subpage (not home)
 * @returns {boolean} true if on a subpage
 */
function isSubPage() {
  return window.location.pathname !== '/' && window.location.pathname !== '';
}

/**
 * Checks if menu interaction should be allowed
 * Only allowed on home page
 * @returns {boolean} true if menu interaction is allowed
 */
function isMenuInteractionAllowed() {
  return !isSubPage();
}

/**
 * Shows the menu with enhanced animation
 * This is a direct DOM manipulation with advanced animations
 */
export function showMenu() {
  // Now delegates to Scene.handleContinue() if available
  if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
    window.sceneInstance.handleContinue();
    return true;
  }
  
  // Fallback to direct DOM manipulation
  if (isSubPage()) {
    console.log('Menu not shown - on subpage');
    return false;
  }

  const menu = document.getElementById('menu');
  const continuePrompt = document.getElementById('continue-prompt');
  
  if (menu) {
    menu.classList.remove('hidden');
    menu.classList.add('visible');
    
    if (continuePrompt) {
      continuePrompt.classList.add('hidden');
    }
    
    return true;
  }
  return false;
}

/**
 * Hides the menu with enhanced animation
 */
export function hideMenu() {
  // Delegate to Scene.closeMenu() if available
  if (window.sceneInstance && typeof window.sceneInstance.closeMenu === 'function') {
    window.sceneInstance.closeMenu();
    return true;
  }
  
  // Fallback to direct DOM manipulation
  const menu = document.getElementById('menu');
  
  if (menu) {
    menu.classList.remove('visible');
    setTimeout(() => {
      menu.classList.add('hidden');
    }, 500);
    
    const continuePrompt = document.getElementById('continue-prompt');
    if (continuePrompt && (window.location.pathname === '/' || window.location.pathname === '')) {
      continuePrompt.classList.remove('hidden');
    }
    
    return true;
  }
  return false;
}

/**
 * Initializes the back button with custom view transition
 */
export function initializeBackButton() {
  // Delegate to EventHandler if available
  if (typeof EventHandler !== 'undefined' && EventHandler.initializeBackButton) {
    EventHandler.initializeBackButton();
    return;
  }
  
  // Fallback implementation
  const backButton = document.getElementById('back-to-home');
  if (backButton) {
    backButton.addEventListener('click', (event) => {
      if (!isSubPage()) {
        event.preventDefault();
        showMenu();
      } else {
        window.navBackToHome = true;
      }
    });
  }
}

/**
 * Function to be called on home page load to prepare the menu
 */
export function setupHomePage() {
  if (!isSubPage()) {
    const continuePrompt = document.getElementById('continue-prompt');
    const menu = document.getElementById('menu');
    
    // Check for back navigation
    if (window.navBackToHome) {
      if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
        setTimeout(() => {
          window.sceneInstance.handleContinue();
          window.navBackToHome = false;
        }, 200);
      }
    } else if (menu && !menu.classList.contains('visible') && continuePrompt) {
      continuePrompt.classList.remove('hidden');
    }
  }
}

/**
 * Handle user interaction (space key or logo click)
 */
export function handleUserTrigger() {
  if (!isMenuInteractionAllowed()) return false;
  
  // Delegate to Scene.handleContinue if available
  if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
    window.sceneInstance.handleContinue();
    return true;
  }
  
  return showMenu();
}

/**
 * Enforce the correct state of the continue prompt
 */
export function enforceContinuePromptState() {
  const menu = document.getElementById('menu');
  const continuePrompt = document.getElementById('continue-prompt');
  
  if (!menu || !continuePrompt) return;
  
  // If menu is visible, ensure prompt is hidden
  if (menu.classList.contains('visible')) {
    continuePrompt.classList.add('hidden');
  } else if (window.location.pathname === '/' || window.location.pathname === '') {
    // If on home page and menu is not visible, ensure prompt is shown
    continuePrompt.classList.remove('hidden');
  }
  
  console.log('Enforced continue prompt state');
}

// Export the helper functions
export { isMenuInteractionAllowed };

================
File: src/utils/UIManager.js
================
/**
 * UIManager.js
 * Handles all direct DOM manipulations for the application
 */

import anime from 'animejs/lib/anime.es.js';
import { AppState } from './AppState';

class UIManagerClass {
  constructor() {
    // Cache for DOM elements to avoid repeated querySelector calls
    this._elements = {
      menu: null,
      continuePrompt: null,
      loadingScreen: null,
      sceneContainer: null
    };
    
    // Last enforcement time to prevent too frequent UI updates
    this._lastEnforcementTime = 0;
  }
  
  /**
   * Initialize and cache DOM elements
   */
  initialize() {
    this._elements = {
      menu: document.getElementById('menu'),
      continuePrompt: document.getElementById('continue-prompt'),
      loadingScreen: document.getElementById('loading-screen'),
      sceneContainer: document.getElementById('scene-container')
    };
    
    console.log('[UIManager] Initialized DOM elements');
  }
  
  /**
   * Get a DOM element, initializing the cache if needed
   */
  getElement(key) {
    if (!this._elements[key]) {
      this._elements[key] = document.getElementById(key);
    }
    return this._elements[key];
  }
  
  /**
   * Show the menu with animation effects
   */
  showMenu() {
    const menu = this.getElement('menu');
    if (!menu) return;
    
    console.log('[UIManager] Showing menu');
    
    // Make menu visible
    menu.classList.remove('hidden');
    menu.classList.add('visible');
    
    // Add ripple effect for visual interest
    this.addRippleEffect(menu);
    
    // Animate menu items
    anime({
      targets: '.menu nav ul li',
      translateY: [20, 0],
      opacity: [0, 1],
      duration: 600,
      delay: anime.stagger(80)
    });
    
    // Hide continue prompt
    this.hideContinuePrompt();
    
    // Scale scene container slightly for depth effect
    const sceneContainer = this.getElement('sceneContainer');
    if (sceneContainer) {
      sceneContainer.style.transition = 'transform 1.5s cubic-bezier(0.19, 1, 0.22, 1)';
      sceneContainer.style.transform = 'scale(1.05)';
    }
    
    // Make home content visible if it exists
    const homeContent = document.querySelector('.home-content');
    if (homeContent) {
      homeContent.style.opacity = '1';
    }
  }
  
  /**
   * Hide the menu with animation effects
   */
  hideMenu() {
    const menu = this.getElement('menu');
    if (!menu) return;
    
    console.log('[UIManager] Hiding menu');
    
    // Fade out menu items with staggered animation
    const menuItems = menu.querySelectorAll('nav ul li');
    menuItems.forEach((item, index) => {
      setTimeout(() => {
        item.style.opacity = '0';
        item.style.transform = 'translateY(-20px)';
      }, index * 50);
    });
    
    // Reset scene container scale
    const sceneContainer = this.getElement('sceneContainer');
    if (sceneContainer) {
      sceneContainer.style.transform = 'scale(1)';
    }
    
    // Fade out menu background
    setTimeout(() => {
      menu.classList.remove('visible');
      
      // Finally hide the menu completely
      setTimeout(() => {
        menu.classList.add('hidden');
        
        // Reset menu items for next time
        menuItems.forEach(item => {
          item.style.opacity = '';
          item.style.transform = '';
        });
      }, 500);
    }, menuItems.length * 50 + 100);
    
    // Show continue prompt if on home page
    if (AppState.isHomePage()) {
      this.showContinuePrompt();
    }
  }
  
  /**
   * Ensure menu is hidden (immediately, without animation)
   */
  ensureMenuHidden() {
    const menu = this.getElement('menu');
    if (!menu) return;
    
    menu.classList.remove('visible');
    menu.classList.add('hidden');
  }
  
  /**
   * Ensure menu is visible (immediately, without animation)
   */
  ensureMenuVisible() {
    const menu = this.getElement('menu');
    if (!menu) return;
    
    menu.classList.remove('hidden');
    menu.classList.add('visible');
  }
  
  /**
   * Show the continue prompt with animation
   */
  showContinuePrompt() {
    const prompt = this.getElement('continuePrompt');
    if (!prompt) return;
    
    console.log('[UIManager] Showing continue prompt');
    
    // Make prompt visible
    prompt.classList.remove('hidden');
    
    // Format text for letter-by-letter animation
    const text = prompt.textContent || '';
    prompt.innerHTML = text.split('').map(char =>
      char === ' ' ? ' ' : `<span>${char}</span>`
    ).join('');
    
    // Animate prompt appearance
    anime.timeline({
      easing: 'easeOutElastic(1, 0.8)'
    })
    .add({
      targets: prompt,
      opacity: 1,
      translateY: [30, 0],
      duration: 800
    })
    .add({
      targets: '#continue-prompt span',
      translateY: [-20, 0],
      opacity: [0, 1],
      delay: anime.stagger(30),
      duration: 600,
      complete: () => {
        prompt.style.opacity = '1';
      }
    }, '-=400');
  }
  
  /**
   * Hide the continue prompt
   */
  hideContinuePrompt() {
    const prompt = this.getElement('continuePrompt');
    if (!prompt) return;
    
    console.log('[UIManager] Hiding continue prompt');
    
    // Animate fadeout
    anime({
      targets: prompt,
      opacity: [1, 0],
      translateY: [0, 30],
      scale: [1, 0.95],
      duration: 600,
      easing: 'easeOutExpo',
      complete: () => prompt.classList.add('hidden')
    });
  }
  
  /**
   * Hide the loading screen
   */
  hideLoadingScreen() {
    const loadingScreen = this.getElement('loadingScreen');
    if (!loadingScreen) return;
    
    console.log('[UIManager] Hiding loading screen');
    
    loadingScreen.style.opacity = '0';
    setTimeout(() => {
      loadingScreen.style.display = 'none';
    }, 500);
  }
  
  /**
   * Add a ripple effect to an element
   */
  addRippleEffect(element) {
    // Create ripple element
    const ripple = document.createElement('div');
    ripple.classList.add('menu-ripple');
    ripple.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(100,149,237,0.3) 0%, transparent 70%);
      pointer-events: none;
      z-index: -1;
    `;
    
    element.appendChild(ripple);
    
    // Animate ripple expansion
    setTimeout(() => {
      ripple.style.transition = 'transform 1s cubic-bezier(0.19, 1, 0.22, 1)';
      ripple.style.transform = 'translate(-50%, -50%) scale(50)';
      
      // Remove after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 1000);
    }, 10);
  }
  
  /**
   * Enforce the correct UI state based on current app state
   * This is a recovery mechanism for when state gets out of sync
   */
  enforceCorrectUIState() {
    // Don't run this too frequently
    const now = Date.now();
    if (now - this._lastEnforcementTime < 300) return;
    this._lastEnforcementTime = now;
    
    console.log('[UIManager] Enforcing correct UI state');
    
    // Only enforce on home page
    if (!AppState.isHomePage()) return;
    
    const menu = this.getElement('menu');
    const continuePrompt = this.getElement('continuePrompt');
    
    if (!menu || !continuePrompt) return;
    
    // Enforce correct UI based on app state
    switch (AppState.currentState) {
      case 'IDLE':
        // Should show continue prompt, hide menu
        if (continuePrompt.classList.contains('hidden')) {
          continuePrompt.classList.remove('hidden');
        }
        if (menu.classList.contains('visible')) {
          menu.classList.remove('visible');
          menu.classList.add('hidden');
        }
        break;
        
      case 'MENU_OPEN':
        // Should hide continue prompt, show menu
        if (!continuePrompt.classList.contains('hidden')) {
          continuePrompt.classList.add('hidden');
        }
        if (!menu.classList.contains('visible')) {
          menu.classList.remove('hidden');
          menu.classList.add('visible');
        }
        break;
        
      default:
        // For other states, don't enforce anything
        break;
    }
  }
}

// Export a singleton instance
export const UIManager = new UIManagerClass();

================
File: tailwind.config.js
================
const plugin = require('tailwindcss/plugin');
const postcss = require('postcss');
const postcssJs = require('postcss-js');

const clampGenerator = require('./src/css-utils/clamp-generator.js');
const tokensToTailwind = require('./src/css-utils/tokens-to-tailwind.js');

// Raw design tokens
const colorTokens = require('./src/design-tokens/colors.json');
const fontTokens = require('./src/design-tokens/fonts.json');
const spacingTokens = require('./src/design-tokens/spacing.json');
const textSizeTokens = require('./src/design-tokens/text-sizes.json');
const textLeadingTokens = require('./src/design-tokens/text-leading.json');
const textWeightTokens = require('./src/design-tokens/text-weights.json');
const viewportTokens = require('./src/design-tokens/viewports.json');

// Process design tokens
const colors = tokensToTailwind(colorTokens.items);
const fontFamily = tokensToTailwind(fontTokens.items);
const fontWeight = tokensToTailwind(textWeightTokens.items);
const fontSize = tokensToTailwind(clampGenerator(textSizeTokens.items));
const lineHeight = tokensToTailwind(textLeadingTokens.items);
const spacing = tokensToTailwind(clampGenerator(spacingTokens.items));

module.exports = {
  content: ['./src/**/*.{html,js,jsx,mdx,njk,twig,vue}'],
  // Add color classes to safe list so they are always generated
  safelist: [],
  presets: [],
  theme: {
    screens: {
      sm: `${viewportTokens.min}px`,
      md: `${viewportTokens.mid}px`,
      lg: `${viewportTokens.max}px`
    },
    colors,
    spacing,
    fontSize,
    lineHeight,
    fontFamily,
    fontWeight,
    backgroundColor: ({theme}) => theme('colors'),
    textColor: ({theme}) => theme('colors'),
    margin: ({theme}) => ({
      auto: 'auto',
      ...theme('spacing')
    }),
    padding: ({theme}) => theme('spacing')
  },
  variantOrder: [
    'first',
    'last',
    'odd',
    'even',
    'visited',
    'checked',
    'empty',
    'read-only',
    'group-hover',
    'group-focus',
    'focus-within',
    'hover',
    'focus',
    'focus-visible',
    'active',
    'disabled'
  ],

  // Disables Tailwind's reset and usage of rgb/opacity
  corePlugins: {
    preflight: false,
    textOpacity: false,
    backgroundOpacity: false,
    borderOpacity: false
  },

  // Prevents Tailwind's core components
  blocklist: ['container'],

  // Prevents Tailwind from generating that wall of empty custom properties 
  experimental: {
    optimizeUniversalDefaults: true
  },

  plugins: [
    // Generates custom property values from tailwind config
    plugin(function ({addComponents, config}) {
      let result = '';

      const currentConfig = config();

      const groups = [
        {key: 'colors', prefix: 'color'},
        {key: 'spacing', prefix: 'space'},
        {key: 'fontSize', prefix: 'size'},
        {key: 'lineHeight', prefix: 'leading'},
        {key: 'fontFamily', prefix: 'font'},
        {key: 'fontWeight', prefix: 'font'}
      ];

      groups.forEach(({key, prefix}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          result += `--${prefix}-${key}: ${group[key]};`;
        });
      });

      addComponents({
        ':root': postcssJs.objectify(postcss.parse(result))
      });
    }),

    // Generates custom utility classes
    plugin(function ({addUtilities, config}) {
      const currentConfig = config();
      const customUtilities = [
        {key: 'spacing', prefix: 'flow-space', property: '--flow-space'},
        {key: 'spacing', prefix: 'region-space', property: '--region-space'},
        {key: 'spacing', prefix: 'gutter', property: '--gutter'}
      ];

      customUtilities.forEach(({key, prefix, property}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          addUtilities({
            [`.${prefix}-${key}`]: postcssJs.objectify(
              postcss.parse(`${property}: ${group[key]}`)
            )
          });
        });
      });
    })
  ]
};
