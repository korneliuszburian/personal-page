This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-02T13:28:14.621Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
astro.config.mjs
notes.md
package.json
postcss.config.cjs
public/favicon.svg
README.md
src/components/Card.astro
src/components/ParticleSystem.ts
src/components/Scene.ts
src/css-utils/clamp-generator.js
src/css-utils/tokens-to-tailwind.js
src/design-tokens/colors.json
src/design-tokens/fonts.json
src/design-tokens/spacing.json
src/design-tokens/text-leading.json
src/design-tokens/text-sizes.json
src/design-tokens/text-weights.json
src/design-tokens/viewports.json
src/env.d.ts
src/layouts/Layout.astro
src/pages/index.astro
src/pages/photos.astro
src/utils/menuState.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

================
File: astro.config.mjs
================
import { defineConfig } from 'astro/config';
import tailwind from "@astrojs/tailwind";
import partytown from "@astrojs/partytown";
import sitemap from "@astrojs/sitemap";

// https://astro.build/config
export default defineConfig({
  integrations: [tailwind({
    applyBaseStyles: false
  }), partytown(), sitemap()]
});

================
File: notes.md
================
## TO FIX:
- re-running logo animation when comming back from any page
- better motion for typography
- respo

## TO DO:
- /items
- /collections (low priority)
- photo gallery deffinitely to adjust, maybe some extending grid on click - some more brutalism
- better lighting for logo
- better view transitions (must understand the context)

### VERY LOW PRIORITY
- increase logo quality - model 3D
- prepare scenes and backgrounds for some more scenerios

================
File: package.json
================
{
  "name": "astro-cube-boilerplate",
  "type": "module",
  "version": "0.0.1",
  "author": "Frank Stallone <frank@stallone.dev>",
  "description": "A simple Astro boilerplate with CUBE CSS and TailwindCSS",
  "homepage": "https://github.com/frankstallone/astro-cube-boilerplate",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro check && astro build",
    "preview": "astro preview",
    "astro": "astro"
  },
  "dependencies": {
    "@astrojs/check": "^0.9.4",
    "@astrojs/partytown": "^2.1.2",
    "@astrojs/sitemap": "^3.2.1",
    "@astrojs/tailwind": "^5.1.4",
    "@types/animejs": "^3.1.12",
    "animejs": "^3.2.1",
    "astro": "^5.1.1",
    "slugify": "^1.6.6",
    "tailwindcss": "^3.4.1",
    "three": "^0.160.0"
  },
  "devDependencies": {
    "@types/three": "^0.174.0",
    "prettier": "^3.2.5",
    "prettier-plugin-astro": "^0.13.0",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=20.12.2"
  },
  "resolutions": {
    "esbuild": "0.24.0"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
  plugins: [
    require('tailwindcss')
  ]
};

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 128 128">
    <path d="M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z" />
    <style>
        path { fill: #000; }
        @media (prefers-color-scheme: dark) {
            path { fill: #FFF; }
        }
    </style>
</svg>

================
File: README.md
================
# Astro CUBE CSS Boilerplate

Based on the [CUBE CSS Boilerplate](https://github.com/Set-Creative-Studio/cube-boilerplate). 

The Astro CUBE CSS Boilerplate is a simple, modern, web platform native starting point with sensible defaults. You get the advantages of modern CSS, with the aid of utility classes, and the affordances of design token architecture. 

Uses:
- [Astro](https://astro.build/), a web framework for content-driven websites
- [Utopia](https://utopia.fyi/), for responsive typography, spacing, and sizing
- [Cube CSS](https://cube.fyi/), a pragmatric and simple CSS methodology
- [Every Layouts](https://every-layout.dev/), better, more resilient CSS
- [Tailwind CSS](https://tailwindcss.com/), a utility-first CSS framework, used as utility-second
- [Partytown](https://partytown.builder.io/), for running third-party scripts in a web worker
- [Astro Sitemap](https://docs.astro.build/en/guides/integrations-guide/sitemap/), for generating a sitemap
- Design tokens, bringing sanity to design decisions.

Read more from Andy Bell's [A CSS project boilerplate
](https://piccalil.li/blog/a-css-project-boilerplate/).

## ðŸ§ž Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

================
File: src/components/Card.astro
================
---
interface Props {
	title: string;
	body: string;
	href: string;
}

const { href, title, body } = Astro.props;
---

<li class="link-card">
	<a href={href}>
		<h2>
			{title}
			<span>&rarr;</span>
		</h2>
		<p>
			{body}
		</p>
	</a>
</li>
<style>
	.link-card {
		list-style: none;
		display: flex;
		padding: 1px;
		background-color: #23262d;
		background-image: none;
		background-size: 400%;
		border-radius: 7px;
		background-position: 100%;
		transition: background-position 0.6s cubic-bezier(0.22, 1, 0.36, 1);
		box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
	}
	.link-card > a {
		width: 100%;
		text-decoration: none;
		line-height: 1.4;
		padding: calc(1.5rem - 1px);
		border-radius: 8px;
		color: white;
		background-color: #23262d;
		opacity: 0.8;
	}
	h2 {
		margin: 0;
		font-size: 1.25rem;
		transition: color 0.6s cubic-bezier(0.22, 1, 0.36, 1);
	}
	p {
		margin-top: 0.5rem;
		margin-bottom: 0;
	}
	.link-card:is(:hover, :focus-within) {
		background-position: 0;
		background-image: var(--accent-gradient);
	}
	.link-card:is(:hover, :focus-within) h2 {
		color: rgb(var(--accent-light));
	}
</style>

================
File: src/components/ParticleSystem.ts
================
// This file can be deleted as we're not using the particle system anymore

================
File: src/components/Scene.ts
================
// src/components/Scene.ts
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import anime from 'animejs/lib/anime.es.js';
import { isMenuInteractionAllowed } from '../utils/menuState.js';
// Custom shader for distortion effects inspired by codrops repositories
const distortionShader = {
  uniforms: {
    "tDiffuse": { value: null },
    "uTime": { value: 0 },
    "uDistortionAmount": { value: 0.0 },
    "uDistortionScale": { value: 10.0 },
    "uMouse": { value: new THREE.Vector2(0.5, 0.5) }
  },
  vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
  fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uDistortionAmount;
        uniform float uDistortionScale;
        uniform vec2 uMouse;
        varying vec2 vUv;
        void main() {
            // Create distortion effect using sine waves
            vec2 distortion = vec2(
                sin(vUv.y * uDistortionScale + uTime * 0.5) * uDistortionAmount,
                sin(vUv.x * uDistortionScale + uTime * 0.5) * uDistortionAmount
            );
            // Apply mouse influence (interactive)
            float mouseDistance = distance(vUv, uMouse);
            float mouseInfluence = smoothstep(0.5, 0.0, mouseDistance) * 0.05;
            vec2 mouseDistortion = normalize(vUv - uMouse) * mouseInfluence * uDistortionAmount * 5.0;
            // Combine effects
            vec2 distortedUv = vUv + distortion + mouseDistortion;
            // Sample the texture with our distorted coordinates
            vec4 color = texture2D(tDiffuse, distortedUv);
            // Add subtle color aberration
            float aberrationAmount = 0.003 * uDistortionAmount;
            color.r = texture2D(tDiffuse, distortedUv + vec2(aberrationAmount, 0.0)).r;
            color.b = texture2D(tDiffuse, distortedUv - vec2(aberrationAmount, 0.0)).b;
            gl_FragColor = color;
        }
    `
};
export class Scene {
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private logo: THREE.Group | null = null;
  private isTransitioning: boolean = false;
  private composer: EffectComposer;
  private initialLogoPosition: THREE.Vector3 | null = null;
  private initialLogoRotation: THREE.Euler | null = null;
  private isMenuOpen: boolean = false;
  private mainBeam!: THREE.SpotLight;
  private beamMesh!: THREE.Mesh;
  private secondaryBeamMesh!: THREE.Mesh;
  private distortionPass!: ShaderPass;
  private particles: THREE.Points | null = null;
  private particlesGeometry: THREE.BufferGeometry | null = null;
  private mousePosition: THREE.Vector2 = new THREE.Vector2(0.5, 0.5);
  private clock: THREE.Clock = new THREE.Clock();
  private transitionDirection: 'in' | 'out' = 'in';
  private gridPlane: THREE.Mesh | null = null;
  private cubeCamera: THREE.CubeCamera | null = null;
  private cubeRenderTarget: THREE.WebGLCubeRenderTarget | null = null;
  constructor(container: HTMLElement) {
    console.log("Constructing Scene");
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.FogExp2(0x000000, 0.004); // Balanced fog density
    this.camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
    this.renderer.toneMappingExposure = 1.2;
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(this.renderer.domElement);
    // Post-processing setup
    this.composer = new EffectComposer(this.renderer);
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);
    // Add bloom effect
    // More balanced bloom effect
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.65,  // Moderate strength
      0.4,   // Moderate radius
      0.85
    );
    this.composer.addPass(bloomPass);
    // Add custom distortion shader (inspired by Codrops distorted-sphere-custom-material)
    this.distortionPass = new ShaderPass(distortionShader);
    this.distortionPass.uniforms["uDistortionAmount"].value = 0.0; // Start with no distortion
    this.composer.addPass(this.distortionPass);
    this.setupScene();
    this.setupParticles(); // Add particle system (inspired by codrops-dreamy-particles)
    this.setupGrid(); // Add grid (inspired by grid-deformation-effect)
    this.animate();
    this.handleResize();
    this.setupInteractions();
    this.setupMouseTracking();
  }
  private setupScene() {
    // Balanced ambient light - not too dark, not too bright
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(ambientLight);
    // More balanced main spotlight
    this.mainBeam = new THREE.SpotLight(0xffffff, 120);
    this.mainBeam.position.set(0, 15, 8);
    this.mainBeam.angle = Math.PI / 4.5;
    this.mainBeam.penumbra = 0.4;
    this.mainBeam.decay = 0.9;
    this.mainBeam.distance = 30;
    this.mainBeam.castShadow = true;
    this.scene.add(this.mainBeam);
    // Subtler front light
    const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
    frontLight.position.set(0, 0, 10);
    frontLight.castShadow = false;
    this.scene.add(frontLight);
    // Subtle rim lights for definition
    const rimLight1 = new THREE.DirectionalLight(0xa0c0ff, 0.5);
    rimLight1.position.set(10, 3, 5);
    this.scene.add(rimLight1);
    const rimLight2 = new THREE.DirectionalLight(0xf0f8ff, 0.5);
    rimLight2.position.set(-10, 3, 5);
    this.scene.add(rimLight2);

    // Create beam meshes with initial opacity of 0 to prevent flash
    const beamGeometry = new THREE.CylinderGeometry(0.2, 2.5, 15, 32, 1, true);
    const beamMaterial = new THREE.MeshBasicMaterial({
      color: 0x4444ff,
      transparent: true,
      opacity: 0,  // Start completely invisible
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending
    });
    this.beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
    this.beamMesh.position.copy(this.mainBeam.position);
    this.beamMesh.rotation.x = Math.PI;
    this.scene.add(this.beamMesh);

    this.secondaryBeamMesh = this.beamMesh.clone();
    const secondaryMaterial = beamMaterial.clone();
    secondaryMaterial.opacity = 0; // Start completely invisible
    secondaryMaterial.color.setHex(0x6666ff);
    this.secondaryBeamMesh.material = secondaryMaterial;
    this.secondaryBeamMesh.scale.set(1.8, 1.2, 1.8);
    this.scene.add(this.secondaryBeamMesh);

    this.camera.position.set(0, 1, 12);
    this.camera.lookAt(0, 0, 0);
    const loader = new GLTFLoader();
    const modelPath = '/glass-like-logo-2.glb';
    console.log('Loading model from:', modelPath);
    loader.load(
      modelPath,
      (gltf) => {
        console.log('Model loaded successfully:', gltf);
        this.logo = gltf.scene;
        const box = new THREE.Box3().setFromObject(this.logo);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 6 / maxDim;
        this.logo.scale.setScalar(scale);
        this.logo.position.sub(center.multiplyScalar(scale));
        this.scene.add(this.logo);
        // Create environment map for reflections
        this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
        this.cubeCamera = new THREE.CubeCamera(1, 1000, this.cubeRenderTarget);
        this.scene.add(this.cubeCamera);
        // More balanced hemisphere light
        const envLight = new THREE.HemisphereLight(0xffffff, 0x404040, 0.8);
        this.scene.add(envLight);
        // Balanced material - visible but not too bright
        const logoMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xaaccff, // Slightly bluish tint
          metalness: 0.85,
          roughness: 0.2,  // Still fairly reflective
          reflectivity: 0.8,
          clearcoat: 0.8,
          clearcoatRoughness: 0.2,
          envMap: this.cubeRenderTarget.texture,
          envMapIntensity: 1.0,
          emissive: 0x101020, // Very subtle self-illumination
          emissiveIntensity: 0.1
        });
        this.logo.traverse((child) => {
          if (child instanceof THREE.Mesh) {
            child.material = logoMaterial;
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        this.initialLogoPosition = this.logo.position.clone();
        this.initialLogoRotation = this.logo.rotation.clone();
        this.hideLoadingScreen();
        this.showContinuePrompt();
        // Create a subtle entrance animation
        this.logo.scale.set(0.01, 0.01, 0.01);
        this.logo.rotation.y = Math.PI * 2;
        anime({
          targets: this.logo.scale,
          x: scale,
          y: scale,
          z: scale,
          duration: 1500,
          easing: 'easeOutElastic(1, 0.5)'
        });
        anime({
          targets: this.logo.rotation,
          y: 0,
          duration: 1500,
          easing: 'easeOutQuad'
        });
      },
      (progress) => {
        const percentComplete = (progress.loaded / progress.total) * 100;
        console.log('Loading progress:', percentComplete.toFixed(2) + '%');
      },
      (error) => {
        console.error('Error loading model:', error);
        console.error('Model path attempted:', modelPath);
        this.hideLoadingScreen();
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshStandardMaterial({ color: 0x6666ff, metalness: 0.8 });
        const cube = new THREE.Mesh(geometry, material);
        this.scene.add(cube);
        this.logo = new THREE.Group();
        this.logo.add(cube);
        this.scene.add(this.logo);
        this.initialLogoPosition = this.logo.position.clone();
        this.initialLogoRotation = this.logo.rotation.clone();
        this.showContinuePrompt();
      }
    );
  }
  // Setup particle system inspired by codrops-dreamy-particles
  private setupParticles() {
    const particleCount = 2000;
    this.particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const scales = new Float32Array(particleCount);
    const opacities = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      // Position particles in a spherical volume
      const radius = 20 + Math.random() * 30;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);
      scales[i] = Math.random() * 0.5 + 0.1;
      opacities[i] = Math.random() * 0.5 + 0.1;
    }
    this.particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    this.particlesGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
    this.particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));
    // Create custom shader material for particles
    const particleMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                attribute float scale;
                attribute float opacity;
                varying float vOpacity;
                uniform float uTime;
                void main() {
                    // Animate particles
                    vec3 pos = position;
                    float offset = position.x + position.y + position.z;
                    pos.x += sin(uTime * 0.2 + offset * 0.1) * 0.5;
                    pos.y += cos(uTime * 0.3 + offset * 0.05) * 0.5;
                    pos.z += sin(uTime * 0.4 + offset * 0.07) * 0.5;
                    // Pass to fragment shader
                    vOpacity = opacity * (0.5 + 0.5 * sin(uTime * 0.3 + offset * 0.2));
                    // Calculate position
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = scale * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
      fragmentShader: `
                varying float vOpacity;
                void main() {
                    // Circular particle with soft edge
                    float dist = length(gl_PointCoord - vec2(0.5));
                    float alpha = smoothstep(0.5, 0.3, dist) * vOpacity;
                    // Blue/purple glow color
                    vec3 color = mix(vec3(0.3, 0.4, 1.0), vec3(0.5, 0.2, 1.0), vOpacity);
                    gl_FragColor = vec4(color, alpha);
                }
            `,
      uniforms: {
        uTime: { value: 0 }
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    this.particles = new THREE.Points(this.particlesGeometry, particleMaterial);
    this.particles.renderOrder = -1; // Render before other objects
    this.scene.add(this.particles);
  }
  private setupGrid() {
    const size = 30;
    const gridGeometry = new THREE.PlaneGeometry(size, size, 32, 32);
    const gridMaterial = new THREE.ShaderMaterial({
      vertexShader: `
                uniform float uTime;
                uniform vec2 uMouse;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    // Create ripple effect from center
                    vec3 pos = position;
                    float dist = distance(vec2(0.5), uv);
                    float ripple = sin(dist * 10.0 - uTime * 0.5) * 0.2;
                    // Mouse influence
                    float mouseStrength = 2.0;
                    float mouseDist = distance(uMouse, uv);
                    float mouseDeformation = smoothstep(0.5, 0.0, mouseDist) * mouseStrength;
                    // Apply deformations only to z-axis
                    pos.z += ripple * (1.0 - dist * 2.0);
                    pos.z += mouseDeformation * (1.0 - mouseDist * 2.0);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
      fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;
                void main() {
                    // Create grid pattern
                    vec2 grid = abs(fract(vUv * 15.0 - 0.5) - 0.5) / fwidth(vUv * 15.0);
                    float line = min(grid.x, grid.y);
                    float gridPattern = 1.0 - min(line, 1.0);
                    // Add some animated color variation
                    vec3 baseColor = vec3(0.2, 0.4, 0.8);
                    baseColor += 0.1 * sin(uTime * 0.2 + vUv.x * 5.0) * vec3(0.5, 0.0, 0.5);
                    // Apply grid pattern with a glow effect
                    vec3 finalColor = mix(baseColor * 0.3, baseColor, gridPattern);
                    float alpha = 0.1 + gridPattern * 0.3;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
      uniforms: {
        uTime: { value: 0 },
        uMouse: { value: new THREE.Vector2(0.5, 0.5) }
      },
      transparent: true,
      side: THREE.DoubleSide,
      wireframe: false,
      blending: THREE.AdditiveBlending
    });
    this.gridPlane = new THREE.Mesh(gridGeometry, gridMaterial);
    this.gridPlane.position.set(0, -5, 0);
    this.gridPlane.rotation.x = -Math.PI / 2;
    this.gridPlane.receiveShadow = true;
    this.scene.add(this.gridPlane);
  }
  private setupInteractions() {
    // Separate flag to track if menu was opened with space key
    let openedWithSpaceKey = false;

    // Special handler for space key
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !this.isTransitioning && isMenuInteractionAllowed()) {
        e.preventDefault(); // Prevent any default space key behavior

        // Mark that we're using space key
        openedWithSpaceKey = true;

        // Completely hide the beams
        if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.beamMesh.material.opacity = 0;
        }
        if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.secondaryBeamMesh.material.opacity = 0;
        }

        // Use CSS transition to hide any potential flashes
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: transparent;
          pointer-events: none;
          z-index: 9999;
        `;
        document.body.appendChild(overlay);

        // Call the continue method with special flag
        this.handleContinue(true);

        // Remove overlay after transition
        setTimeout(() => {
          overlay.remove();
        }, 1000);
      }
    });

    window.addEventListener('click', (e) => {
      if (this.logo && !this.isTransitioning && isMenuInteractionAllowed()) {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(
          (e.clientX / window.innerWidth) * 2 - 1,
          -(e.clientY / window.innerHeight) * 2 + 1
        );
        raycaster.setFromCamera(mouse, this.camera);
        const intersects = raycaster.intersectObject(this.logo, true);
        if (intersects.length > 0) {
          // Regular continue for mouse clicks
          this.handleContinue(false);
        }
      }
    });
  }
  private setupMouseTracking() {
    window.addEventListener('mousemove', (e) => {
      this.mousePosition.x = e.clientX / window.innerWidth;
      this.mousePosition.y = 1 - (e.clientY / window.innerHeight);
      if (this.distortionPass) {
        this.distortionPass.uniforms.uMouse.value = this.mousePosition;
      }
      if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
        this.gridPlane.material.uniforms.uMouse.value = this.mousePosition;
      }
    });
  }
  private handleContinue(isSpaceKey = false) {
    if (this.isMenuOpen || this.isTransitioning) return;
    this.isTransitioning = true;
    const menu = document.getElementById('menu');
    const prompt = document.getElementById('continue-prompt');
    this.isMenuOpen = true;
    const currentY = this.logo!.position.y;
    if (prompt) {
      anime({
        targets: prompt,
        opacity: [1, 0],
        translateY: [0, 30],
        scale: [1, 0.95],
        duration: 600,
        easing: 'easeOutExpo',
        complete: () => prompt.classList.add('hidden')
      });
    }

    // Different behavior for space key vs click
    if (isSpaceKey) {
      // Immediately ensure beams are invisible when using space key
      if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
        this.beamMesh.material.opacity = 0;
      }
      if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
        this.secondaryBeamMesh.material.opacity = 0;
      }
    }

    // Apply distortion without changing beam opacity
    anime({
      targets: this.distortionPass.uniforms.uDistortionAmount,
      value: [0, 0.05, 0],
      duration: 1200,
      easing: 'easeInOutQuad',
      complete: () => {
        this.distortionPass.uniforms.uDistortionAmount.value = 0;
      }
    });

    const timeline = anime.timeline({
      easing: 'easeInOutQuad'
    });

    timeline
      .add({
        targets: this.logo!.position,
        y: currentY + 3,
        duration: 1200,
        easing: 'easeOutQuad'
      })
      .add({
        targets: this.logo!.rotation,
        y: Math.PI * 3,
        duration: 1200,
        easing: 'easeInOutQuad'
      }, '-=1200')
      .add({
        targets: this.logo!.position,
        y: currentY - 1,
        duration: 800,
        easing: 'easeOutBounce'
      })
      .add({
        targets: this.logo!.rotation,
        y: Math.PI * 4,
        duration: 1000,
        easing: 'easeOutQuad'
      }, '-=800')
      .add({
        targets: '#continue-prompt',
        opacity: 0,
        duration: 300
      }, '-=1000')
      .add({
        begin: () => {
          if (menu) {
            menu.classList.remove('hidden');
            menu.classList.add('visible');
          }

          // For space key, delay beam appearance much longer
          if (isSpaceKey) {
            // First make sure beams are definitely invisible
            if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
              this.beamMesh.material.opacity = 0;
            }
            if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
              this.secondaryBeamMesh.material.opacity = 0;
            }

            // Then fade in very gradually after menu is fully visible
            setTimeout(() => {
              anime({
                targets: [
                  this.beamMesh.material,
                  this.secondaryBeamMesh.material
                ],
                opacity: [0, 0.2],
                duration: 1000,
                easing: 'easeOutQuad'
              });
            }, 800); // Longer delay for space key
          } else {
            // Normal beam animation for mouse clicks
            anime({
              targets: [
                this.beamMesh.material,
                this.secondaryBeamMesh.material
              ],
              opacity: [0, 0.2],
              delay: 400,
              duration: 600,
              easing: 'easeOutQuad'
            });
          }
        }
      })
      .add({
        targets: '.menu nav ul li',
        translateY: [20, 0],
        opacity: [0, 1],
        duration: 600,
        delay: anime.stagger(80),
        complete: () => {
          this.isTransitioning = false;
        }
      });

    const closeMenu = () => {
      if (!this.isTransitioning && this.isMenuOpen) {
        this.isTransitioning = true;

        // Immediately hide beams when closing menu starts
        anime({
          targets: [
            this.beamMesh.material,
            this.secondaryBeamMesh.material
          ],
          opacity: 0,
          duration: 400,
          easing: 'easeOutQuad'
        });

        anime({
          targets: this.distortionPass.uniforms.uDistortionAmount,
          value: [0, 0.08, 0],
          duration: 1000,
          easing: 'easeInOutQuad',
          complete: () => {
            this.distortionPass.uniforms.uDistortionAmount.value = 0;
          }
        });

        const closeTimeline = anime.timeline({
          easing: 'easeInOutQuad'
        });

        closeTimeline
          .add({
            targets: '.menu nav ul li',
            translateY: [0, -20],
            opacity: [1, 0],
            duration: 400,
            delay: anime.stagger(50, { direction: 'reverse' })
          })
          .add({
            targets: '.menu',
            opacity: 0,
            duration: 400,
            complete: () => {
              if (menu) {
                menu.classList.add('hidden');
                menu.classList.remove('visible');
              }
            }
          })
          .add({
            targets: this.logo!.position,
            y: currentY + 2,
            duration: 800,
            easing: 'easeOutQuad'
          })
          .add({
            targets: this.logo!.rotation,
            y: this.initialLogoRotation!.y,
            duration: 1200,
            easing: 'easeInOutQuad'
          }, '-=800')
          .add({
            targets: this.logo!.position,
            y: this.initialLogoPosition!.y,
            duration: 1000,
            easing: 'easeOutElastic(1, 0.8)',
            complete: () => {
              this.isTransitioning = false;
              this.isMenuOpen = false;
            }
          });
      }
    };

    if (menu) {
      menu.addEventListener('click', (e) => {
        if (e.target === menu) {
          closeMenu();
        }
      });
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Escape' && this.isMenuOpen) {
          closeMenu();
        }
      });
    }
  }
  private animate = () => {
    requestAnimationFrame(this.animate);
    const time = this.clock.getElapsedTime();
    // Update shader uniforms with time
    if (this.distortionPass) {
      this.distortionPass.uniforms.uTime.value = time;
    }
    // Update particle animation
    if (this.particles && this.particles.material instanceof THREE.ShaderMaterial) {
      this.particles.material.uniforms.uTime.value = time;
    }
    // Update grid animation
    if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
      this.gridPlane.material.uniforms.uTime.value = time;
    }
    if (this.logo) {
      // Only animate beam and lighting if menu is open and not transitioning
      if (this.isMenuOpen && !this.isTransitioning) {
        this.logo.rotation.y += 0.0005;
        const pulseIntensity = Math.sin(time * 0.5) * 0.3 + 0.7;
        this.mainBeam.intensity = 120 + (30 * pulseIntensity);

        // Only modify beam opacity when menu is open and not transitioning
        if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.beamMesh.material.opacity = 0.2 + (0.1 * pulseIntensity);
        }
        if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.secondaryBeamMesh.material.opacity = 0.15 + (0.05 * pulseIntensity);
        }

        this.scene.fog = new THREE.FogExp2(0x000000, 0.004 + (0.001 * pulseIntensity));
        // Subtle glow animation
        if (this.logo) {
          this.logo.traverse((child) => {
            if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
              child.material.emissiveIntensity = 0.1 + 0.05 * pulseIntensity;
            }
          });
        }
      } else if (!this.isTransitioning) {
        this.logo.rotation.y += 0.001;
        this.logo.position.y = Math.sin(time * 0.5) * 0.1 + Math.sin(time * 0.2) * 0.03;
        this.logo.rotation.x = Math.sin(time * 0.3) * 0.02;
        this.logo.rotation.z = Math.cos(time * 0.2) * 0.02;
        // Balanced intensity for good visibility
        this.mainBeam.intensity = 100;

        // Keep beams invisible when menu is closed
        if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.beamMesh.material.opacity = 0;
        }
        if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
          this.secondaryBeamMesh.material.opacity = 0;
        }

        this.scene.fog = new THREE.FogExp2(0x000000, 0.004);
        // Very subtle breathing effect
        const breatheIntensity = Math.sin(time * 0.4) * 0.1 + 0.9;
        if (this.logo) {
          this.logo.traverse((child) => {
            if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
              child.material.emissiveIntensity = 0.08 + 0.03 * breatheIntensity;
            }
          });
        }
      }
      // Update environment map every few frames for better reflections
      if (Math.floor(time * 10) % 10 === 0) {
        this.updateLogoEnvMap();
      }
    }
    this.composer.render();
  }
  public prepareForTransition() {
    if (this.logo) {
      this.isTransitioning = true;
      // Set transition direction based on current state
      if (this.isMenuOpen) {
        this.transitionDirection = 'out';
      } else {
        this.transitionDirection = 'in';
      }
      // Add visual effects during page transitions
      anime({
        targets: this.distortionPass.uniforms.uDistortionAmount,
        value: [0, 0.2, 0],
        duration: 1000,
        easing: 'easeInOutQuad'
      });
      anime.remove(this.logo.position);
      anime.remove(this.logo.rotation);

      // Ensure beams are hidden during page transitions
      if (this.beamMesh.material instanceof THREE.MeshBasicMaterial) {
        this.beamMesh.material.opacity = 0;
      }
      if (this.secondaryBeamMesh.material instanceof THREE.MeshBasicMaterial) {
        this.secondaryBeamMesh.material.opacity = 0;
      }

      // Page transition animation
      if (this.transitionDirection === 'out') {
        anime({
          targets: this.logo.scale,
          x: this.logo.scale.x * 0.8,
          y: this.logo.scale.y * 0.8,
          z: this.logo.scale.z * 0.8,
          duration: 500,
          easing: 'easeInQuad'
        });
        anime({
          targets: this.logo.position,
          y: this.logo.position.y - 2,
          duration: 500,
          easing: 'easeInQuad'
        });
      } else {
        anime({
          targets: this.logo.scale,
          x: this.logo.scale.x * 1.2,
          y: this.logo.scale.y * 1.2,
          z: this.logo.scale.z * 1.2,
          duration: 500,
          easing: 'easeOutQuad',
          complete: () => {
            anime({
              targets: this.logo.scale,
              x: this.logo.scale.x / 1.2,
              y: this.logo.scale.y / 1.2,
              z: this.logo.scale.z / 1.2,
              duration: 800,
              easing: 'easeOutElastic(1, 0.5)'
            });
          }
        });
      }
      setTimeout(() => {
        this.isTransitioning = false;
      }, 800);
    }
  }
  private handleResize = () => {
    window.addEventListener('resize', () => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.composer.setSize(window.innerWidth, window.innerHeight);
    });
  }
  /**
   * Updates the environment map for the logo to enhance reflections
   */
  private updateLogoEnvMap() {
    if (this.logo && this.cubeCamera && this.cubeRenderTarget) {
      // Temporarily hide the logo for environment capture
      this.logo.visible = false;
      // Update the cube camera
      this.cubeCamera.update(this.renderer, this.scene);
      // Make the logo visible again
      this.logo.visible = true;
      // Update the material's environment map for all meshes in the logo
      this.logo.traverse((child) => {
        if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
          child.material.envMap = this.cubeRenderTarget.texture;
        }
      });
    }
  }
  private hideLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      loadingScreen.style.opacity = '0';
      setTimeout(() => {
        loadingScreen.style.display = 'none';
      }, 500);
    }
  }
  private showContinuePrompt() {
    const prompt = document.getElementById('continue-prompt');
    if (prompt) {
      prompt.classList.remove('hidden');
      const text = prompt.textContent || '';
      prompt.innerHTML = text.split('').map(char =>
        char === ' ' ? ' ' : `<span>${char}</span>`
      ).join('');
      anime.timeline({
        easing: 'easeOutElastic(1, 0.8)'
      })
        .add({
          targets: prompt,
          opacity: 1,
          translateY: [30, 0],
          duration: 800
        })
        .add({
          targets: '#continue-prompt span',
          translateY: [-20, 0],
          opacity: [0, 1],
          delay: anime.stagger(30),
          duration: 600,
          complete: () => {
            prompt.style.opacity = '1';
          }
        }, '-=400');
    }
  }
}

================
File: src/css-utils/clamp-generator.js
================
const viewports = require('../design-tokens/viewports.json');

/**
 * Takes an array of tokens and sends back and array of name
 * and clamp pairs for CSS fluid values.
 *
 * @param {array} tokens array of {name: string, min: number, max: number}
 * @returns {array} {name: string, value: string}
 */
const clampGenerator = tokens => {
  const rootSize = 16;

  return tokens.map(({name, min, max}) => {
    if (min === max) {
      return `${min / rootSize}rem`;
    }

    // Convert the min and max sizes to rems
    const minSize = min / rootSize;
    const maxSize = max / rootSize;

    // Convert the pixel viewport sizes into rems
    const minViewport = viewports.min / rootSize;
    const maxViewport = viewports.max / rootSize;

    // Slope and intersection allow us to have a fluid value but also keep that sensible
    const slope = (maxSize - minSize) / (maxViewport - minViewport);
    const intersection = -1 * minViewport * slope + minSize;

    return {
      name,
      value: `clamp(${minSize}rem, ${intersection.toFixed(2)}rem + ${(
        slope * 100
      ).toFixed(2)}vw, ${maxSize}rem)`
    };
  });
};

module.exports = clampGenerator;

================
File: src/css-utils/tokens-to-tailwind.js
================
const slugify = require('slugify');

/**
 * Converts human readable tokens into tailwind config friendly ones
 *
 * @param {array} tokens {name: string, value: any}
 * @return {object} {key, value}
 */
const tokensToTailwind = tokens => {
  const nameSlug = text => slugify(text, {lower: true});
  let response = {};

  tokens.forEach(({name, value}) => {
    response[nameSlug(name)] = value;
  });

  return response;
};

module.exports = tokensToTailwind;

================
File: src/design-tokens/colors.json
================
{
  "title": "Colors",
  "description": "Hex color codes that can be shared, cross-platform. They can be converted at point of usage, such as HSL for web or CMYK for print.",
  "items": [
    {
      "name": "Transparent",
      "value": "transparent"
    },
    {
      "name": "Dark",
      "value": "#030303"
    },
    {
      "name": "Light",
      "value": "#ffffff"
    },
    {
      "name": "Primary",
      "value": "#02394A"
    }
  ]
}

================
File: src/design-tokens/fonts.json
================
{
  "title": "Fonts",
  "description": "Each array of fonts creates a priority-based order. The first font in the array should be the ideal font, followed by sensible, web-safe fallbacks",
  "items": [
    {
      "name": "Base",
      "description": "System fonts for body copy and globally set text.",
      "value": ["Inter", "Segoe UI", "Roboto", "Helvetica Neue", "Arial", "sans-serif"]
    }
  ]
}

================
File: src/design-tokens/spacing.json
================
{
  "title": "Spacing",
  "description": "Consistent spacing sizes, based on a ratio, with min and max sizes. This allows you to set spacing based on the context size. For example, min for mobile and max for desktop browsers.",
  "meta": {
    "scaleGenerator": "https://utopia.fyi/space/calculator/?c=330,18,1.2,1200,24,1.25,6,2,&s=0.75|0.5|0.25,1.5|2|3|4|6|8,s-l|s-xl&g=s,l,xl,12"
  },
  "items": [
    {
      "name": "Zero",
      "min": 0,
      "max": 1
    },
    {
      "name": "3XS",
      "min": 5,
      "max": 6
    },
    {
      "name": "2XS",
      "min": 9,
      "max": 12
    },
    {
      "name": "XS",
      "min": 14,
      "max": 18
    },
    {
      "name": "S",
      "min": 18,
      "max": 24
    },
    {
      "name": "M",
      "min": 27,
      "max": 36
    },
    {
      "name": "L",
      "min": 36,
      "max": 48
    },
    {
      "name": "XL",
      "min": 54,
      "max": 72
    },
    {
      "name": "2XL",
      "min": 72,
      "max": 96
    },
    {
      "name": "3XL",
      "min": 108,
      "max": 144
    },
    {
      "name": "4XL",
      "min": 144,
      "max": 192
    },
    {
      "name": "3XS - 2XS",
      "min": 5,
      "max": 12
    },
    {
      "name": "2XS - XS",
      "min": 9,
      "max": 18
    },
    {
      "name": "XS - S",
      "min": 14,
      "max": 24
    },
    {
      "name": "S - M",
      "min": 18,
      "max": 36
    },
    {
      "name": "M - L",
      "min": 27,
      "max": 48
    },
    {
      "name": "L - XL",
      "min": 36,
      "max": 72
    },
    {
      "name": "XL - 2XL",
      "min": 54,
      "max": 96
    },
    {
      "name": "2XL - 3XL",
      "min": 72,
      "max": 144
    },
    {
      "name": "3XL - 4XL",
      "min": 108,
      "max": 192
    },
    {
      "name": "S - L",
      "min": 18,
      "max": 48
    },
    {
      "name": "S - XL",
      "min": 18,
      "max": 72
    }
  ]
}

================
File: src/design-tokens/text-leading.json
================
{
  "title": "Leading",
  "description": "Ratio-based leading/line-height values",
  "items": [
    {
      "name": "Flat",
      "value": 1
    },
    {
      "name": "Fine",
      "value": 1.15
    },
    {
      "name": "Standard",
      "value": 1.5
    },
    {
      "name": "Loose",
      "value": 1.7
    }
  ]
}

================
File: src/design-tokens/text-sizes.json
================
{
  "title": "Text Sizes",
  "description": "A minimum and maximum text size size allows you to pick the right size from a ratio, depending on the context size. The min and max sizes are in pixels and should be converted to appropiate sizes, per context. For example, for web, the should be converted to REM units (pixelSize / baseSize)",
  "meta": {
    "scaleGenerator": "https://utopia.fyi/type/calculator/?c=330,18,1.175,1200,24,1.25,7,1,&s=0.75%7C0.5%7C0.25,1.5%7C2%7C3%7C4%7C6,s-l&g=s,l,xl,12"
  },
  "items": [
    {
      "name": "Step 000",
      "min": 12,
      "max": 14
    },
    {
      "name": "Step 00",
      "min": 15,
      "max": 16
    },
    {
      "name": "Step 0",
      "min": 18,
      "max": 20
    },
    {
      "name": "Step 1",
      "min": 21.6,
      "max": 25
    },
    {
      "name": "Step 2",
      "min": 25.92,
      "max": 31.25
    },
    {
      "name": "Step 3",
      "min": 31.1,
      "max": 39.06
    },
    {
      "name": "Step 4",
      "min": 39.06,
      "max": 48.83
    },
    {
      "name": "Step 5",
      "min": 44.79,
      "max": 61.04
    }
  ]
}

================
File: src/design-tokens/text-weights.json
================
{
  "title": "Text Weights",
  "description": "Helper classes and custom properties for common font weights",
  "meta": {},
  "items": [
    {
      "name": "Regular",
      "value": 400
    },
    {
      "name": "Medium",
      "value": 500
    },
    {
      "name": "Bold",
      "value": 700
    }
  ]
}

================
File: src/design-tokens/viewports.json
================
{
  "title": "Viewports",
  "description": "The min and maximum viewports used to generate fluid type and space scales.",
  "min": 330,
  "mid": 760,
  "max": 1230
}

================
File: src/env.d.ts
================
/// <reference types="astro/client" />

================
File: src/layouts/Layout.astro
================
---
import "../css/global.css";
import { ClientRouter } from "astro:transitions";
interface Props {
  title: string;
}
const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Thrifted streetwear shop" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap"
      rel="stylesheet"
    />
    <title>{title}</title>
    <ClientRouter />
  </head>
  <body>
    <!-- Loading screen -->
    <div id="loading-screen" transition:persist>
      <div class="loader"></div>
    </div>

    <!-- Three.js scene container - this is just for the 3D background -->
    <div id="scene-container" transition:persist>
      <!-- Three.js canvas will be inserted here -->
    </div>

    <!-- Continue prompt -->
    <div id="continue-prompt" class="hidden" transition:persist>
      Press Space or Click Logo to Continue
    </div>

    <!-- Menu overlay -->
    <div id="menu" class="menu hidden" transition:persist>
      <nav>
        <ul>
          <li><a href="#" class="strike">Nowa kolekcja</a></li>
          <li><a href="/photos">ZdjÄ™cia</a></li>
          <li><a href="#posters">Plakaty</a></li>
          <li><a href="#items">Itemy</a></li>
        </ul>
      </nav>
    </div>

    <!-- Page content container - separate from the 3D background -->
    <main id="page-content">
      <slot />
    </main>
    <style>
      #loading-screen {
        position: fixed;
        width: 100vw;
        height: 100vh;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 5px solid #333;
        border-top-color: #fff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      #scene-container {
        position: fixed;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        background: #000;
      }

      #page-content {
        position: relative;
        z-index: 5;
        width: 100%;
        min-height: 100vh;
      }

      #continue-prompt {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: "Rajdhani", sans-serif;
        font-size: 1.4rem;
        font-weight: 500;
        opacity: 0;
        z-index: 100;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        text-shadow:
          0 0 10px rgba(255, 255, 255, 0.5),
          0 0 20px rgba(255, 255, 255, 0.3);
        animation: glowPulse 3s infinite;
        white-space: nowrap;
        transform-origin: center bottom;
        transition: none;
      }

      @keyframes glowPulse {
        0%,
        100% {
          opacity: 0.7;
          transform: translateX(-50%) scale(0.98);
          text-shadow:
            0 0 10px rgba(255, 255, 255, 0.3),
            0 0 20px rgba(255, 255, 255, 0.2);
        }
        50% {
          opacity: 1;
          transform: translateX(-50%) scale(1);
          text-shadow:
            0 0 15px rgba(255, 255, 255, 0.5),
            0 0 30px rgba(255, 255, 255, 0.3),
            0 0 40px rgba(100, 149, 237, 0.3);
        }
      }

      .hidden {
        display: none;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.8);
        opacity: 0;
        transition: opacity 0.5s;
        pointer-events: none;
        z-index: 500;
      }

      .menu.visible {
        opacity: 1;
        pointer-events: all;
      }

      .menu nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
        text-align: center;
      }

      .menu nav ul li {
        margin: 2rem 0;
        transform: translateY(20px);
        opacity: 0;
        transition: all 0.3s;
      }

      .menu.visible nav ul li {
        transform: translateY(0);
        opacity: 1;
      }

      .menu nav ul li a {
        font-family: "Rajdhani", sans-serif;
        font-weight: 700;
        letter-spacing: 0.1em;
        color: white;
        text-decoration: none;
        font-size: 2rem;
        transition: color 0.3s;
      }

      .menu nav ul li a:hover {
        color: #f0f0f0;
      }

      .menu nav ul li a.strike {
        text-decoration: line-through;
        opacity: 0.5;
        pointer-events: none;
      }
    </style>

    <script>
      import { Scene } from "../components/Scene";
      import { showMenu, setupHomePage, handleUserTrigger } from "../utils/menuState.js";

      let sceneInstance: Scene | undefined;
      let menuVisible = false;

      // Initialize the scene on first page load
      function initScene() {
        const container = document.getElementById("scene-container");
        if (container && !document.querySelector("#scene-container canvas")) {
          console.log("Initializing Scene");
          const scene = new Scene(container);
          sceneInstance = scene;
        }
      }

      // Setup menu handlers
      function setupMenuHandlers() {
        const menu = document.getElementById("menu");
        if (!menu) return;

        // Handle navigation clicks for all menu items
        const navLinks = document.querySelectorAll(
          ".menu nav ul li a:not(.strike)"
        );
        navLinks.forEach((link) => {
          link.addEventListener("click", () => {
            if (!link.classList.contains("strike")) {
              menuVisible = false;
              menu.classList.remove("visible");
            }
          });
        });

        // Handle the space key or logo click to show menu initially
        const handleContinue = () => {
          // Use the handleUserTrigger function from menuState.js
          if (handleUserTrigger()) {
            menuVisible = true;
          }
        };

        // Add global space key handler
        document.addEventListener("keydown", (e) => {
          if (e.code === "Space") {
            handleContinue();
          }
        });

        // Handle logo click (via event delegation)
        document.addEventListener("click", (e) => {
          // Check if we clicked the 3D logo (using raycasting in Scene.ts)
          // This is handled in Scene.ts, but we can provide a fallback here
          if (
            (e.target as HTMLElement).id === "scene-container" ||
            (e.target as HTMLElement).tagName === "CANVAS"
          ) {
            handleContinue();
          }
        });
      }

      // Check if we're on the home page
      function isHomePage() {
        return (
          window.location.pathname === "/" || window.location.pathname === ""
        );
      }

      // When transitioning between pages
      document.addEventListener("astro:before-navigation", (e) => {
        // Prepare scene for transition
        if (sceneInstance) {
          sceneInstance.prepareForTransition();
        }
      });

      // After navigation completes
      document.addEventListener("astro:after-navigation", () => {
        // If we're on the home page, show the menu
        if (isHomePage()) {
          console.log("after-navigation: On home page, showing menu");
          setupHomePage();
        }
      });

      // Initial page load
      document.addEventListener("DOMContentLoaded", () => {
        initScene();
        setupMenuHandlers();

        // If we're on the home page, show the menu
        if (isHomePage()) {
          console.log("DOMContentLoaded: On home page, setting up");
          setupHomePage();
        }
      });

      // After any component updates
      document.addEventListener("astro:load", () => {
        // Reinitialize scene if needed
        if (!document.querySelector("#scene-container canvas")) {
          initScene();
        }

        setupMenuHandlers();

        // If we're on the home page, check if we need to show the menu
        if (isHomePage()) {
          console.log("astro:load: On home page, checking menu");
          const continuePrompt = document.getElementById("continue-prompt");
          const menu = document.getElementById("menu");

          if (
            continuePrompt &&
            continuePrompt.classList.contains("hidden") &&
            menu &&
            !menu.classList.contains("visible")
          ) {
            console.log(
              "Auto-showing menu because intro animation is complete"
            );
            showMenu();
          }
        }
      });

      // Listen for view transitions end to ensure menu is visible when needed
      document.addEventListener("astro:page-load", () => {
        if (isHomePage()) {
          console.log("astro:page-load: On home page, final check");
          setupHomePage();
        }
      });
    </script>
  </body>
</html>

================
File: src/pages/index.astro
================
---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Thrifted streetwear shop">
  <div class="home-content"></div>
</Layout>

<script>
  import { initializeBackButton } from "../utils/menuState.js";

  document.addEventListener("DOMContentLoaded", () => {
    initializeBackButton();
  });
</script>

<style>
  .home-content {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    color: white;
    text-align: center;
    padding: 2rem;
    opacity: 0;
    transition: opacity 0.5s ease;
  }

  :global(#menu.visible) ~ .home-content {
    opacity: 1;
  }

  h1 {
    font-family: "Rajdhani", sans-serif;
    font-size: 3rem;
    font-weight: 700;
    margin-bottom: 1rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    text-shadow:
      0 0 15px rgba(255, 255, 255, 0.3),
      0 0 30px rgba(100, 149, 237, 0.3);
  }

  p {
    font-family: "Outfit", sans-serif;
    font-size: 1.2rem;
    max-width: 600px;
    margin: 0 auto;
  }
</style>

================
File: src/pages/photos.astro
================
---
import Layout from '../layouts/Layout.astro';
---
<Layout title="Photos | Thrifted streetwear shop">
  <div class="photos-container">
    <div class="photos-header">
      <h1>Photo Gallery</h1>
      <a href="/" class="back-button" id="back-to-home">Back to Home</a>
    </div>

    <div class="photos-grid">
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149569710.jpg?t=st=1740863882~exp=1740867482~hmac=6e3d92db1518edc3a4d0b5b5a35aa3a7a19ed441fa85dab3d2affb7697539349&w=740" alt="Fantasy cards" />
        <div class="photo-caption">Fantasy Collection</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149587976.jpg?t=st=1740862298~exp=1740865898~hmac=b864d9a601321fc767eee479f266893401ee4d2df748a8a0b8099b64be36fe39&w=740" alt="Card game" />
        <div class="photo-caption">Tournament Series</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/abstract-female-portrait-made-different-shapes_23-2149126821.jpg?t=st=1740863207~exp=1740866807~hmac=76d19808c0afa3df81c0741231ff6f09b45eecbe73caaf3082dbbfcf4cd3bbcb&w=740" alt="Trading cards" />
        <div class="photo-caption">Limited Edition</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-picasso-style-illustration_23-2149602595.jpg?t=st=1740863890~exp=1740867490~hmac=019c3c6037c207bf001290e43da83e06b5ab075fb1f38c8357923e6b554552ac&w=1060" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-flat-abstract-shapes-collection_23-2149085348.jpg?t=st=1740863893~exp=1740867493~hmac=3719b5d78cd491929bc8275ed968419491b209f122ea53f33820c04f90e1c489&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/flat-design-geometric-pattern-illustration_23-2150010041.jpg?t=st=1740863897~exp=1740867497~hmac=71cd7c54211a7809daec097a498c20e1aa307b794959936f53e99964f678c3bc&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
    </div>
  </div>
</Layout>

<script>
import { initializeBackButton } from '../utils/menuState.js';

document.addEventListener('DOMContentLoaded', () => {
  // Initialize the back button handling
  initializeBackButton();
  // No need for additional event listeners as it's handled in initializeBackButton
});
</script>

<style>
  .photos-container {
    position: relative;
    z-index: 10;
    padding: 4rem 2rem;
    color: white;
    max-width: 1200px;
    margin: 0 auto;
    opacity: 0;
    animation: fadeIn 0.8s forwards;
    animation-delay: 0.3s;
  }

  .photos-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 3rem;
    flex-wrap: wrap;
    gap: 1rem;
  }

  h1 {
    font-family: 'Rajdhani', sans-serif;
    font-size: 3rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    text-shadow: 0 0 15px rgba(255,255,255,0.3),
                 0 0 30px rgba(100,149,237,0.3);
    margin: 0;
  }

  .back-button {
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: white;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3);
    padding: 0.6rem 1.2rem;
    border-radius: 4px;
    text-decoration: none;
    transition: all 0.3s ease;
  }

  .back-button:hover {
    background: rgba(100, 149, 237, 0.2);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }

  .photos-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
  }

  .photo-item {
    position: relative;
    aspect-ratio: 4/3;
    overflow: hidden;
    border-radius: 8px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
  }

  .photo-item:hover {
    transform: scale(1.02) translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
  }

  .photo-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.3s ease, transform 0.5s ease;
  }

  .photo-item:hover img {
    opacity: 0.9;
    transform: scale(1.05);
  }

  .photo-caption {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-family: 'Outfit', sans-serif;
    font-weight: 500;
    transform: translateY(100%);
    transition: transform 0.3s ease;
  }

  .photo-item:hover .photo-caption {
    transform: translateY(0);
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  @media (max-width: 768px) {
    .photos-header {
      flex-direction: column;
      align-items: flex-start;
    }

    h1 {
      font-size: 2.2rem;
    }

    .photos-grid {
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 1.5rem;
    }
  }
</style>

================
File: src/utils/menuState.js
================
/**
 * Checks if current page is a subpage (not home)
 * @returns {boolean} true if on a subpage
 */
function isSubPage() {
  return window.location.pathname !== '/' && window.location.pathname !== '';
}

/**
 * Checks if menu interaction should be allowed
 * Only allowed on home page
 * @returns {boolean} true if menu interaction is allowed
 */
function isMenuInteractionAllowed() {
  return !isSubPage();
}

/**
 * Shows the menu with enhanced animation
 * This is a direct DOM manipulation with advanced animations
 */
export function showMenu() {
  // Don't automatically show menu on subpages
  if (isSubPage()) {
    console.log('Menu not shown - on subpage');
    return false;
  }

  const menu = document.getElementById('menu');
  const continuePrompt = document.getElementById('continue-prompt');
  const scene = document.getElementById('scene-container');

  if (menu) {
    // Make sure hidden class is removed
    menu.classList.remove('hidden');

    // Add visible class with animation
    menu.classList.add('visible');

    // Apply ripple effect to menu background
    const ripple = document.createElement('div');
    ripple.classList.add('menu-ripple');
    ripple.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(100,149,237,0.3) 0%, transparent 70%);
      pointer-events: none;
      z-index: -1;
    `;

    menu.appendChild(ripple);

    // Animate ripple
    setTimeout(() => {
      ripple.style.transition = 'transform 1s cubic-bezier(0.19, 1, 0.22, 1)';
      ripple.style.transform = 'translate(-50%, -50%) scale(50)';

      // Clean up after animation
      setTimeout(() => {
        ripple.remove();
      }, 1000);
    }, 10);

    // Also hide the continue prompt as it's not needed when menu is shown
    if (continuePrompt) {
      continuePrompt.classList.add('hidden');
    }

    // Make home content visible if it exists
    const homeContent = document.querySelector('.home-content');
    if (homeContent) {
      homeContent.style.opacity = '1';
    }

    // Add subtle camera movement to the scene
    if (scene) {
      scene.style.transition = 'transform 1.5s cubic-bezier(0.19, 1, 0.22, 1)';
      scene.style.transform = 'scale(1.05)';
    }

    console.log('Menu shown with enhanced animation');
    return true;
  }
  return false;
}

/**
 * Hides the menu with enhanced animation
 */
export function hideMenu() {
  const menu = document.getElementById('menu');
  const scene = document.getElementById('scene-container');

  if (menu) {
    // Fade out menu items first
    const menuItems = menu.querySelectorAll('nav ul li');
    menuItems.forEach((item, index) => {
      setTimeout(() => {
        item.style.opacity = '0';
        item.style.transform = 'translateY(-20px)';
      }, index * 50);
    });

    // Then fade out the menu background
    setTimeout(() => {
      menu.classList.remove('visible');

      // Reset scene scale
      if (scene) {
        scene.style.transform = 'scale(1)';
      }

      // Finally hide the menu
      setTimeout(() => {
        menu.classList.add('hidden');

        // Reset menu items for next time
        menuItems.forEach(item => {
          item.style.opacity = '';
          item.style.transform = '';
        });
      }, 500);
    }, menuItems.length * 50 + 100);

    return true;
  }
  return false;
}

/**
 * Initializes the back button with custom view transition
 */
export function initializeBackButton() {
  document.addEventListener('DOMContentLoaded', () => {
    const backButton = document.getElementById('back-to-home');
    if (backButton) {
      // Keep the default navigation behavior but add transition effect
      backButton.addEventListener('click', (event) => {
        // If we're already on the home page, just show the menu
        if (!isSubPage()) {
          event.preventDefault(); // Prevent navigation if already home
          showMenu();
        } else {
          // Apply custom transition when navigating to home page
          // This works in conjunction with Astro's View Transitions
          // by adding additional visual effects
          triggerCustomTransition();
        }
      });
    }
  });
}

/**
 * Triggers a custom DOM-based transition effect
 * This works alongside Astro's View Transitions
 */
function triggerCustomTransition() {
  // Create a transition overlay
  const overlay = document.createElement('div');
  overlay.classList.add('page-transition-overlay');
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    z-index: 999;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s ease;
  `;

  document.body.appendChild(overlay);

  // Fade in overlay
  requestAnimationFrame(() => {
    overlay.style.opacity = '0.8';
  });

  // Clean up overlay after navigation
  // Astro's View Transitions will handle the rest
  setTimeout(() => {
    overlay.remove();
  }, 800);
}

/**
 * Function to be called on home page load to prepare the menu
 * Enhanced with improved animations
 */
export function setupHomePage() {
  // Check if we're on the home page
  if (!isSubPage()) {
    // Show the continue prompt
    const continuePrompt = document.getElementById('continue-prompt');
    if (continuePrompt) {
      continuePrompt.classList.remove('hidden');

      // Add subtle pulse animation to make it more noticeable
      const pulseAnimation = document.createElement('style');
      pulseAnimation.textContent = `
        @keyframes promptPulse {
          0%, 100% { transform: translateX(-50%) scale(1); }
          50% { transform: translateX(-50%) scale(1.05); }
        }
        #continue-prompt {
          animation: glowPulse 3s infinite, promptPulse 2s infinite;
        }
      `;
      document.head.appendChild(pulseAnimation);
    }

    // Ensure menu is hidden until user interaction
    const menu = document.getElementById('menu');
    if (menu) {
      menu.classList.add('hidden');
      menu.classList.remove('visible');
    }
  }
}

/**
 * Handle user interaction (space key or logo click)
 * Enhanced with improved animations
 * @returns {boolean} Whether menu was shown
 */
export function handleUserTrigger() {
  // Only allow on home page
  if (!isMenuInteractionAllowed()) {
    return false;
  }

  const menu = document.getElementById('menu');
  if (menu && !menu.classList.contains('visible')) {
    return showMenu();
  }

  return false;
}

/**
 * Registers custom view transitions with Astro
 * Should be called early in the application lifecycle
 */
export function registerViewTransitions() {
  if (typeof document !== 'undefined') {
    document.addEventListener('astro:before-preparation', (event) => {
      // Access the Astro View Transitions event
      const astroEvent = event;

      // Check if this is a navigation between specific pages
      const fromPath = window.location.pathname;
      const toPath = new URL(astroEvent.to).pathname;

      // Apply custom transitions based on route patterns
      if (fromPath === '/' && toPath === '/photos') {
        // From home to photos: use particle transition
        astroEvent.direction = 'forward';
        astroEvent.transition = customTransitions.particleDissolve;
      }
      else if (fromPath === '/photos' && toPath === '/') {
        // From photos to home: use distortion transition
        astroEvent.direction = 'backward';
        astroEvent.transition = customTransitions.distortion;
      }
      else {
        // Default enhanced transition for other routes
        astroEvent.transition = customTransitions.slide3D;
      }
    });
  }
}

// Export the helper functions
export { isMenuInteractionAllowed };

================
File: tailwind.config.js
================
const plugin = require('tailwindcss/plugin');
const postcss = require('postcss');
const postcssJs = require('postcss-js');

const clampGenerator = require('./src/css-utils/clamp-generator.js');
const tokensToTailwind = require('./src/css-utils/tokens-to-tailwind.js');

// Raw design tokens
const colorTokens = require('./src/design-tokens/colors.json');
const fontTokens = require('./src/design-tokens/fonts.json');
const spacingTokens = require('./src/design-tokens/spacing.json');
const textSizeTokens = require('./src/design-tokens/text-sizes.json');
const textLeadingTokens = require('./src/design-tokens/text-leading.json');
const textWeightTokens = require('./src/design-tokens/text-weights.json');
const viewportTokens = require('./src/design-tokens/viewports.json');

// Process design tokens
const colors = tokensToTailwind(colorTokens.items);
const fontFamily = tokensToTailwind(fontTokens.items);
const fontWeight = tokensToTailwind(textWeightTokens.items);
const fontSize = tokensToTailwind(clampGenerator(textSizeTokens.items));
const lineHeight = tokensToTailwind(textLeadingTokens.items);
const spacing = tokensToTailwind(clampGenerator(spacingTokens.items));

module.exports = {
  content: ['./src/**/*.{html,js,jsx,mdx,njk,twig,vue}'],
  // Add color classes to safe list so they are always generated
  safelist: [],
  presets: [],
  theme: {
    screens: {
      sm: `${viewportTokens.min}px`,
      md: `${viewportTokens.mid}px`,
      lg: `${viewportTokens.max}px`
    },
    colors,
    spacing,
    fontSize,
    lineHeight,
    fontFamily,
    fontWeight,
    backgroundColor: ({theme}) => theme('colors'),
    textColor: ({theme}) => theme('colors'),
    margin: ({theme}) => ({
      auto: 'auto',
      ...theme('spacing')
    }),
    padding: ({theme}) => theme('spacing')
  },
  variantOrder: [
    'first',
    'last',
    'odd',
    'even',
    'visited',
    'checked',
    'empty',
    'read-only',
    'group-hover',
    'group-focus',
    'focus-within',
    'hover',
    'focus',
    'focus-visible',
    'active',
    'disabled'
  ],

  // Disables Tailwind's reset and usage of rgb/opacity
  corePlugins: {
    preflight: false,
    textOpacity: false,
    backgroundOpacity: false,
    borderOpacity: false
  },

  // Prevents Tailwind's core components
  blocklist: ['container'],

  // Prevents Tailwind from generating that wall of empty custom properties 
  experimental: {
    optimizeUniversalDefaults: true
  },

  plugins: [
    // Generates custom property values from tailwind config
    plugin(function ({addComponents, config}) {
      let result = '';

      const currentConfig = config();

      const groups = [
        {key: 'colors', prefix: 'color'},
        {key: 'spacing', prefix: 'space'},
        {key: 'fontSize', prefix: 'size'},
        {key: 'lineHeight', prefix: 'leading'},
        {key: 'fontFamily', prefix: 'font'},
        {key: 'fontWeight', prefix: 'font'}
      ];

      groups.forEach(({key, prefix}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          result += `--${prefix}-${key}: ${group[key]};`;
        });
      });

      addComponents({
        ':root': postcssJs.objectify(postcss.parse(result))
      });
    }),

    // Generates custom utility classes
    plugin(function ({addUtilities, config}) {
      const currentConfig = config();
      const customUtilities = [
        {key: 'spacing', prefix: 'flow-space', property: '--flow-space'},
        {key: 'spacing', prefix: 'region-space', property: '--region-space'},
        {key: 'spacing', prefix: 'gutter', property: '--gutter'}
      ];

      customUtilities.forEach(({key, prefix, property}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          addUtilities({
            [`.${prefix}-${key}`]: postcssJs.objectify(
              postcss.parse(`${property}: ${group[key]}`)
            )
          });
        });
      });
    })
  ]
};

================
File: tsconfig.json
================
{
  "extends": "astro/tsconfigs/strict",
  "exclude": ["./dist"]
}
