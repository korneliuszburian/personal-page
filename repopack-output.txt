This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-03T18:49:39.435Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
astro.config.mjs
notes.md
package.json
postcss.config.cjs
public/favicon.svg
README.md
src/components/Card.astro
src/components/ParticleSystem.ts
src/components/Scene.ts
src/css-utils/clamp-generator.js
src/css-utils/tokens-to-tailwind.js
src/css/blocks/landing.css
src/css/blocks/photos.css
src/css/blocks/prose.css
src/css/blocks/test.css
src/css/components/box.css
src/css/components/cluster.css
src/css/components/flow.css
src/css/components/grid.css
src/css/components/icon.css
src/css/components/repel.css
src/css/components/sidebar.css
src/css/components/switcher.css
src/css/components/wrapper.css
src/css/global.css
src/css/global/fonts.css
src/css/global/global-styles.css
src/css/global/reset.css
src/css/global/variables.css
src/css/repopack-output.txt
src/css/utilities/fade-in.css
src/css/utilities/region.css
src/css/utilities/visually-hidden.css
src/design-tokens/colors.json
src/design-tokens/fonts.json
src/design-tokens/spacing.json
src/design-tokens/text-leading.json
src/design-tokens/text-sizes.json
src/design-tokens/text-weights.json
src/design-tokens/viewports.json
src/env.d.ts
src/layouts/Layout.astro
src/pages/index.astro
src/pages/photos.astro
src/types/global.d.ts
src/utils/AnimationManager.js
src/utils/AppState.js
src/utils/EventHandler.js
src/utils/menuState.js
src/utils/UIManager.js
tailwind.config.js
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# build output
dist/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production

# macOS-specific files
.DS_Store

================
File: astro.config.mjs
================
import { defineConfig } from 'astro/config';
import tailwind from "@astrojs/tailwind";
import partytown from "@astrojs/partytown";
import sitemap from "@astrojs/sitemap";

// https://astro.build/config
export default defineConfig({
  integrations: [tailwind({
    applyBaseStyles: false
  }), partytown(), sitemap()]
});

================
File: notes.md
================
## TO FIX:
- re-running logo animation when comming back from any page
- better motion for typography
- respo

## TO DO:
- /items
- /collections (low priority)
- photo gallery deffinitely to adjust, maybe some extending grid on click - some more brutalism
- better lighting for logo
- better view transitions (must understand the context)

### VERY LOW PRIORITY
- increase logo quality - model 3D
- prepare scenes and backgrounds for some more scenerios

================
File: package.json
================
{
  "name": "astro-cube-boilerplate",
  "type": "module",
  "version": "0.0.1",
  "author": "Frank Stallone <frank@stallone.dev>",
  "description": "A simple Astro boilerplate with CUBE CSS and TailwindCSS",
  "homepage": "https://github.com/frankstallone/astro-cube-boilerplate",
  "scripts": {
    "dev": "astro dev",
    "start": "astro dev",
    "build": "astro check && astro build",
    "preview": "astro preview",
    "astro": "astro"
  },
  "dependencies": {
    "@astrojs/check": "^0.9.4",
    "@astrojs/partytown": "^2.1.2",
    "@astrojs/sitemap": "^3.2.1",
    "@astrojs/tailwind": "^5.1.4",
    "@types/animejs": "^3.1.12",
    "animejs": "^3.2.1",
    "astro": "^5.1.1",
    "slugify": "^1.6.6",
    "tailwindcss": "^3.4.1",
    "three": "^0.160.0"
  },
  "devDependencies": {
    "@types/three": "^0.174.0",
    "prettier": "^3.2.5",
    "prettier-plugin-astro": "^0.13.0",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=20.12.2"
  },
  "resolutions": {
    "esbuild": "0.24.0"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
  plugins: [
    require('tailwindcss')
  ]
};

================
File: public/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 128 128">
    <path d="M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z" />
    <style>
        path { fill: #000; }
        @media (prefers-color-scheme: dark) {
            path { fill: #FFF; }
        }
    </style>
</svg>

================
File: README.md
================
# Astro CUBE CSS Boilerplate

Based on the [CUBE CSS Boilerplate](https://github.com/Set-Creative-Studio/cube-boilerplate). 

The Astro CUBE CSS Boilerplate is a simple, modern, web platform native starting point with sensible defaults. You get the advantages of modern CSS, with the aid of utility classes, and the affordances of design token architecture. 

Uses:
- [Astro](https://astro.build/), a web framework for content-driven websites
- [Utopia](https://utopia.fyi/), for responsive typography, spacing, and sizing
- [Cube CSS](https://cube.fyi/), a pragmatric and simple CSS methodology
- [Every Layouts](https://every-layout.dev/), better, more resilient CSS
- [Tailwind CSS](https://tailwindcss.com/), a utility-first CSS framework, used as utility-second
- [Partytown](https://partytown.builder.io/), for running third-party scripts in a web worker
- [Astro Sitemap](https://docs.astro.build/en/guides/integrations-guide/sitemap/), for generating a sitemap
- Design tokens, bringing sanity to design decisions.

Read more from Andy Bell's [A CSS project boilerplate
](https://piccalil.li/blog/a-css-project-boilerplate/).

## ðŸ§ž Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action                                           |
| :------------------------ | :----------------------------------------------- |
| `npm install`             | Installs dependencies                            |
| `npm run dev`             | Starts local dev server at `localhost:4321`      |
| `npm run build`           | Build your production site to `./dist/`          |
| `npm run preview`         | Preview your build locally, before deploying     |
| `npm run astro ...`       | Run CLI commands like `astro add`, `astro check` |
| `npm run astro -- --help` | Get help using the Astro CLI                     |

================
File: src/components/Card.astro
================
---
interface Props {
	title: string;
	body: string;
	href: string;
}

const { href, title, body } = Astro.props;
---

<li class="link-card">
	<a href={href}>
		<h2>
			{title}
			<span>&rarr;</span>
		</h2>
		<p>
			{body}
		</p>
	</a>
</li>
<style>
	.link-card {
		list-style: none;
		display: flex;
		padding: 1px;
		background-color: #23262d;
		background-image: none;
		background-size: 400%;
		border-radius: 7px;
		background-position: 100%;
		transition: background-position 0.6s cubic-bezier(0.22, 1, 0.36, 1);
		box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
	}
	.link-card > a {
		width: 100%;
		text-decoration: none;
		line-height: 1.4;
		padding: calc(1.5rem - 1px);
		border-radius: 8px;
		color: white;
		background-color: #23262d;
		opacity: 0.8;
	}
	h2 {
		margin: 0;
		font-size: 1.25rem;
		transition: color 0.6s cubic-bezier(0.22, 1, 0.36, 1);
	}
	p {
		margin-top: 0.5rem;
		margin-bottom: 0;
	}
	.link-card:is(:hover, :focus-within) {
		background-position: 0;
		background-image: var(--accent-gradient);
	}
	.link-card:is(:hover, :focus-within) h2 {
		color: rgb(var(--accent-light));
	}
</style>

================
File: src/components/ParticleSystem.ts
================
// This file can be deleted as we're not using the particle system anymore

================
File: src/components/Scene.ts
================
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import anime from 'animejs/lib/anime.es.js';

// Define distortion shader - keeping the original implementation
const distortionShader = {
    uniforms: {
        "tDiffuse": { value: null },
        "uTime": { value: 0 },
        "uDistortionAmount": { value: 0.0 },
        "uDistortionScale": { value: 10.0 },
        "uMouse": { value: new THREE.Vector2(0.5, 0.5) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uDistortionAmount;
        uniform float uDistortionScale;
        uniform vec2 uMouse;
        varying vec2 vUv;

        void main() {
            // Create distortion effect using sine waves
            vec2 distortion = vec2(
                sin(vUv.y * uDistortionScale + uTime * 0.5) * uDistortionAmount,
                sin(vUv.x * uDistortionScale + uTime * 0.5) * uDistortionAmount
            );

            // Apply mouse influence (interactive)
            float mouseDistance = distance(vUv, uMouse);
            float mouseInfluence = smoothstep(0.5, 0.0, mouseDistance) * 0.05;
            vec2 mouseDistortion = normalize(vUv - uMouse) * mouseInfluence * uDistortionAmount * 5.0;

            // Combine effects
            vec2 distortedUv = vUv + distortion + mouseDistortion;

            // Sample the texture with our distorted coordinates
            vec4 color = texture2D(tDiffuse, distortedUv);

            // Add subtle color aberration
            float aberrationAmount = 0.003 * uDistortionAmount;
            color.r = texture2D(tDiffuse, distortedUv + vec2(aberrationAmount, 0.0)).r;
            color.b = texture2D(tDiffuse, distortedUv - vec2(aberrationAmount, 0.0)).b;

            gl_FragColor = color;
        }
    `
};

/**
 * Helper function to check if we're on the home page
 */
function isHomePage() {
    return window.location.pathname === '/' || window.location.pathname === '';
}

export class Scene {
    private scene: THREE.Scene;
    public camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    public logo: THREE.Group | null = null;
    public isTransitioning: boolean = false;
    private composer: EffectComposer;
    public initialLogoPosition: THREE.Vector3 | null = null;
    public initialLogoRotation: THREE.Euler | null = null;
    private isMenuOpen: boolean = false;
    private mainBeam!: THREE.SpotLight;
    private beamMesh!: THREE.Mesh;
    private secondaryBeamMesh!: THREE.Mesh;
    public distortionPass!: ShaderPass;
    private particles: THREE.Points | null = null;
    private particlesGeometry: THREE.BufferGeometry | null = null;
    private mousePosition: THREE.Vector2 = new THREE.Vector2(0.5, 0.5);
    private clock: THREE.Clock = new THREE.Clock();
    private transitionDirection: 'in' | 'out' = 'in';
    private gridPlane: THREE.Mesh | null = null;
    private cubeCamera: THREE.CubeCamera | null = null;
    private cubeRenderTarget: THREE.WebGLCubeRenderTarget | null = null;

    constructor(container: HTMLElement) {
        console.log("Constructing Scene");

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000000, 0.004); // Balanced fog density

        this.camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        container.appendChild(this.renderer.domElement);

        // Post-processing setup
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // Add bloom effect
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.65,  // Moderate strength
            0.4,   // Moderate radius
            0.85
        );
        this.composer.addPass(bloomPass);

        // Add custom distortion shader
        this.distortionPass = new ShaderPass(distortionShader);
        this.distortionPass.uniforms["uDistortionAmount"].value = 0.0; // Start with no distortion
        this.composer.addPass(this.distortionPass);

        this.setupScene();
        this.setupParticles();
        this.setupGrid();
        this.animate();
        this.handleResize();
        this.setupMouseTracking();
        this.setupMenuNavigation();

        // Register this instance globally for access by other modules
        window.sceneInstance = this;
    }

    /**
     * Setup menu navigation click handling
     */
    private setupMenuNavigation() {
        // Add event listener to all menu items
        const menuItems = document.querySelectorAll('.menu nav ul li a:not(.strike)');
        menuItems.forEach(item => {
            item.addEventListener('click', () => {
                // Animate menu away when navigating
                this.animateMenuAway();
            });
        });
    }

    /**
     * Animate the menu away when navigating
     */
    public animateMenuAway() {
        const menu = document.getElementById('menu');
        if (!menu || !menu.classList.contains('visible')) return;

        console.log("Animating menu away");

        // Use AnimationManager if available
        if (window.AnimationManager && typeof window.AnimationManager.animateMenuOut === 'function') {
            window.AnimationManager.animateMenuOut(menu);
            this.isMenuOpen = false;
            return;
        }

        // Fallback animation
        anime({
            targets: '.menu nav ul li',
            translateY: [0, -20],
            opacity: [1, 0],
            duration: 400,
            delay: anime.stagger(50, { direction: 'reverse' }),
            easing: 'easeOutQuad'
        });

        anime({
            targets: menu,
            opacity: 0,
            duration: 500,
            easing: 'easeOutQuad',
            complete: () => {
                menu.classList.add('hidden');
                menu.classList.remove('visible');
                this.isMenuOpen = false;
            }
        });
    }

    private setupScene() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        this.mainBeam = new THREE.SpotLight(0xffffff, 120);
        this.mainBeam.position.set(0, 15, 8);
        this.mainBeam.angle = Math.PI / 4.5;
        this.mainBeam.penumbra = 0.4;
        this.mainBeam.decay = 0.9;
        this.mainBeam.distance = 30;
        this.mainBeam.castShadow = true;
        this.scene.add(this.mainBeam);

        const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
        frontLight.position.set(0, 0, 10);
        frontLight.castShadow = false;
        this.scene.add(frontLight);

        const rimLight1 = new THREE.DirectionalLight(0xa0c0ff, 0.5);
        rimLight1.position.set(10, 3, 5);
        this.scene.add(rimLight1);

        const rimLight2 = new THREE.DirectionalLight(0xf0f8ff, 0.5);
        rimLight2.position.set(-10, 3, 5);
        this.scene.add(rimLight2);

        const beamGeometry = new THREE.CylinderGeometry(0.2, 2.5, 15, 32, 1, true);
        const beamMaterial = new THREE.MeshBasicMaterial({
            color: 0x4444ff,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        this.beamMesh = new THREE.Mesh(beamGeometry, beamMaterial);
        this.beamMesh.position.copy(this.mainBeam.position);
        this.beamMesh.rotation.x = Math.PI;
        this.scene.add(this.beamMesh);

        this.secondaryBeamMesh = this.beamMesh.clone();
        const secondaryMaterial = beamMaterial.clone();
        secondaryMaterial.opacity = 0.1;
        secondaryMaterial.color.setHex(0x6666ff);
        this.secondaryBeamMesh.material = secondaryMaterial;
        this.secondaryBeamMesh.scale.set(1.8, 1.2, 1.8);
        this.scene.add(this.secondaryBeamMesh);

        // Important: Set camera position with proper distance
        this.camera.position.set(0, 1, 12);
        this.camera.lookAt(0, 0, 0);

        // Load the logo model
        this.loadLogo();
    }

    /**
     * Load the 3D logo model
     */
    private loadLogo() {
        const loader = new GLTFLoader();
        const modelPath = '/glass-like-logo-2.glb';
        console.log('Loading model from:', modelPath);

        loader.load(
            // Model path
            modelPath,

            // Success callback
            (gltf) => {
                console.log('Model loaded successfully');
                this.logo = gltf.scene;

                // Calculate bounding box for proper positioning
                const box = new THREE.Box3().setFromObject(this.logo);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 6 / maxDim;

                // Scale the model to a reasonable size
                this.logo.scale.setScalar(scale);

                // Position the logo properly (center it)
                this.logo.position.sub(center.multiplyScalar(scale));

                // Add to scene
                this.scene.add(this.logo);

                // Setup environment mapping for reflections
                this.setupEnvironmentMapping();

                // Store initial position and rotation for reference
                this.initialLogoPosition = this.logo.position.clone();
                this.initialLogoRotation = this.logo.rotation.clone();

                // Hide loading screen
                this.hideLoadingScreen();

                // Only show continue prompt on home page
                if (isHomePage()) {
                    this.showContinuePrompt();
                }

                // Use AnimationManager to animate entrance if available
                if (window.AnimationManager && typeof window.AnimationManager.animateLogoEntrance === 'function') {
                    window.AnimationManager.animateLogoEntrance(this.logo);
                } else {
                    // Fallback entrance animation
                    this.logo.scale.set(0.01, 0.01, 0.01);
                    this.logo.rotation.y = Math.PI * 2;

                    anime({
                        targets: this.logo.scale,
                        x: scale,
                        y: scale,
                        z: scale,
                        duration: 1500,
                        easing: 'easeOutElastic(1, 0.5)'
                    });

                    anime({
                        targets: this.logo.rotation,
                        y: 0,
                        duration: 1500,
                        easing: 'easeOutQuad'
                    });
                }
            },

            // Progress callback
            (progress) => {
                const percentComplete = (progress.loaded / progress.total) * 100;
                console.log('Loading progress:', percentComplete.toFixed(2) + '%');
            },

            // Error callback
            (error) => {
                console.error('Error loading model:', error);
                this.createFallbackLogo();
            }
        );
    }

    /**
     * Create a fallback cube if model loading fails
     */
    private createFallbackLogo() {
        console.log('Creating fallback logo');
        this.hideLoadingScreen();

        // Create a simple cube as fallback
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshStandardMaterial({ color: 0x6666ff, metalness: 0.8 });
        const cube = new THREE.Mesh(geometry, material);

        this.logo = new THREE.Group();
        this.logo.add(cube);
        this.scene.add(this.logo);

        this.initialLogoPosition = this.logo.position.clone();
        this.initialLogoRotation = this.logo.rotation.clone();

        // Show continue prompt on home page
        if (isHomePage()) {
            this.showContinuePrompt();
        }
    }

    /**
     * Set up environment mapping for the logo
     */
    private setupEnvironmentMapping() {
        if (!this.logo) return;

        this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
        this.cubeCamera = new THREE.CubeCamera(1, 1000, this.cubeRenderTarget);
        this.scene.add(this.cubeCamera);

        const envLight = new THREE.HemisphereLight(0xffffff, 0x404040, 0.8);
        this.scene.add(envLight);

        const logoMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xaaccff,
            metalness: 0.85,
            roughness: 0.2,
            reflectivity: 0.8,
            clearcoat: 0.8,
            clearcoatRoughness: 0.2,
            envMap: this.cubeRenderTarget.texture,
            envMapIntensity: 1.0,
            emissive: 0x101020,
            emissiveIntensity: 0.1
        });

        this.logo.traverse((child) => {
            if (child instanceof THREE.Mesh) {
                child.material = logoMaterial;
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });
    }

    private setupParticles() {
        const particleCount = 2000;
        this.particlesGeometry = new THREE.BufferGeometry();

        const positions = new Float32Array(particleCount * 3);
        const scales = new Float32Array(particleCount);
        const opacities = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const radius = 20 + Math.random() * 30;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = radius * Math.cos(phi);

            scales[i] = Math.random() * 0.5 + 0.1;
            opacities[i] = Math.random() * 0.5 + 0.1;
        }

        this.particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.particlesGeometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
        this.particlesGeometry.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                attribute float scale;
                attribute float opacity;
                varying float vOpacity;
                uniform float uTime;

                void main() {
                    vec3 pos = position;
                    float offset = position.x + position.y + position.z;
                    pos.x += sin(uTime * 0.2 + offset * 0.1) * 0.5;
                    pos.y += cos(uTime * 0.3 + offset * 0.05) * 0.5;
                    pos.z += sin(uTime * 0.4 + offset * 0.07) * 0.5;

                    vOpacity = opacity * (0.5 + 0.5 * sin(uTime * 0.3 + offset * 0.2));

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = scale * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying float vOpacity;

                void main() {
                    float dist = length(gl_PointCoord - vec2(0.5));
                    float alpha = smoothstep(0.5, 0.3, dist) * vOpacity;

                    vec3 color = mix(vec3(0.3, 0.4, 1.0), vec3(0.5, 0.2, 1.0), vOpacity);

                    gl_FragColor = vec4(color, alpha);
                }
            `,
            uniforms: {
                uTime: { value: 0 }
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        this.particles = new THREE.Points(this.particlesGeometry, particleMaterial);
        this.particles.renderOrder = -1;
        this.scene.add(this.particles);
    }

    private setupGrid() {
        const size = 30;
        const gridGeometry = new THREE.PlaneGeometry(size, size, 32, 32);

        const gridMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                uniform float uTime;
                uniform vec2 uMouse;
                varying vec2 vUv;

                void main() {
                    vUv = uv;

                    vec3 pos = position;
                    float dist = distance(vec2(0.5), uv);
                    float ripple = sin(dist * 10.0 - uTime * 0.5) * 0.2;

                    float mouseStrength = 2.0;
                    float mouseDist = distance(uMouse, uv);
                    float mouseDeformation = smoothstep(0.5, 0.0, mouseDist) * mouseStrength;

                    pos.z += ripple * (1.0 - dist * 2.0);
                    pos.z += mouseDeformation * (1.0 - mouseDist * 2.0);

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;

                void main() {
                    vec2 grid = abs(fract(vUv * 15.0 - 0.5) - 0.5) / fwidth(vUv * 15.0);
                    float line = min(grid.x, grid.y);
                    float gridPattern = 1.0 - min(line, 1.0);

                    vec3 baseColor = vec3(0.2, 0.4, 0.8);
                    baseColor += 0.1 * sin(uTime * 0.2 + vUv.x * 5.0) * vec3(0.5, 0.0, 0.5);

                    vec3 finalColor = mix(baseColor * 0.3, baseColor, gridPattern);
                    float alpha = 0.1 + gridPattern * 0.3;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) }
            },
            transparent: true,
            side: THREE.DoubleSide,
            wireframe: false,
            blending: THREE.AdditiveBlending
        });

        this.gridPlane = new THREE.Mesh(gridGeometry, gridMaterial);
        this.gridPlane.position.set(0, -5, 0);
        this.gridPlane.rotation.x = -Math.PI / 2;
        this.gridPlane.receiveShadow = true;
        this.scene.add(this.gridPlane);
    }

    private setupMouseTracking() {
        window.addEventListener('mousemove', (e) => {
            this.mousePosition.x = e.clientX / window.innerWidth;
            this.mousePosition.y = 1 - (e.clientY / window.innerHeight);

            if (this.distortionPass) {
                this.distortionPass.uniforms.uMouse.value = this.mousePosition;
            }

            if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
                this.gridPlane.material.uniforms.uMouse.value = this.mousePosition;
            }
        });
    }

    // Main handler for "continue" action (opening the menu)
    public handleContinue() {
        console.log('Scene.handleContinue called');

        // Prevent triggering if menu is already open or transitioning
        if (this.isMenuOpen || this.isTransitioning) {
            console.log('Cannot handle continue: menu open or transitioning', {
                isMenuOpen: this.isMenuOpen,
                isTransitioning: this.isTransitioning
            });
            return;
        }

        // Only handle continue on home page
        if (!isHomePage()) {
            console.log('Cannot handle continue: not on home page');
            return;
        }

        console.log('Handling continue action - opening menu with animations');
        this.isTransitioning = true;
        const menu = document.getElementById('menu');
        const prompt = document.getElementById('continue-prompt');

        this.isMenuOpen = true;

        // Hide continue prompt with animation (using AnimationManager if available)
        if (prompt) {
            if (window.AnimationManager && typeof window.AnimationManager.animateContinuePromptOut === 'function') {
                window.AnimationManager.animateContinuePromptOut(prompt);
            } else {
                // Fallback animation
                anime({
                    targets: prompt,
                    opacity: [1, 0],
                    duration: 600,
                    easing: 'easeOutExpo',
                    complete: () => prompt.classList.add('hidden')
                });
            }
        }

        // Apply distortion effect (using AnimationManager if available)
        if (window.AnimationManager && typeof window.AnimationManager.animateDistortion === 'function') {
            window.AnimationManager.animateDistortion(0.1, 2000, 'menuOpen');
        } else if (this.distortionPass) {
            // Fallback animation
            anime({
                targets: this.distortionPass.uniforms.uDistortionAmount,
                value: [0, 0.1, 0],
                duration: 2000,
                easing: 'easeInOutQuad'
            });
        }

        // Animate logo if it exists (using AnimationManager if available)
        if (this.logo) {
            if (window.AnimationManager && typeof window.AnimationManager.animateLogoForMenuOpen === 'function') {
                window.AnimationManager.animateLogoForMenuOpen(this.logo, () => {
                    // After logo animation completes, show menu
                    this.showMenu(menu);
                });
            } else {
                // Fallback animation
                this.animateLogoForMenuOpenFallback(() => {
                    // After logo animation completes, show menu
                    this.showMenu(menu);
                });
            }
        } else {
            // No logo, just show the menu
            this.showMenu(menu);
        }
    }

    /**
     * Fallback animation for logo when opening menu
     */
    private animateLogoForMenuOpenFallback(onComplete = null) {
        if (!this.logo) return;

        const currentY = this.logo.position.y;

        const timeline = anime.timeline({
            easing: 'easeInOutQuad'
        });

        timeline
            .add({
                targets: this.logo.position,
                y: currentY + 3,
                duration: 1200,
                easing: 'easeOutQuad'
            })
            .add({
                targets: this.logo.rotation,
                y: Math.PI * 3,
                duration: 1200,
                easing: 'easeInOutQuad'
            }, '-=1200')
            .add({
                targets: this.logo.position,
                y: currentY - 1,
                duration: 800,
                easing: 'easeOutBounce'
            })
            .add({
                targets: this.logo.rotation,
                y: Math.PI * 4,
                duration: 1000,
                easing: 'easeOutQuad',
                complete: () => {
                    if (onComplete) onComplete();
                }
            }, '-=800');
    }

    /**
     * Show the menu with animation
     */
    private showMenu(menu) {
        if (!menu) return;

        if (window.AnimationManager && typeof window.AnimationManager.animateMenuIn === 'function') {
            window.AnimationManager.animateMenuIn(menu, () => {
                this.isTransitioning = false;
            });
        } else {
            // Fallback animation
            menu.classList.remove('hidden');
            menu.classList.add('visible');

            // Reset menu items for animation
            const menuItems = menu.querySelectorAll('nav ul li');
            menuItems.forEach(item => {
                (item as HTMLElement).style.opacity = '0';
                (item as HTMLElement).style.transform = 'translateY(20px)';
            });

            anime({
                targets: '.menu nav ul li',
                translateY: [20, 0],
                opacity: [0, 1],
                duration: 600,
                delay: anime.stagger(80),
                complete: () => {
                    this.isTransitioning = false;
                }
            });
        }
    }

    /**
     * Close the menu with animations
     */
    public closeMenu() {
        if (this.isTransitioning) {
            console.log('Cannot close menu: transitioning');
            return;
        }

        if (!this.isMenuOpen) {
            console.log('Cannot close menu: menu not open');
            return;
        }

        this.isTransitioning = true;
        const menu = document.getElementById('menu');

        // Apply distortion effect (using AnimationManager if available)
        if (window.AnimationManager && typeof window.AnimationManager.animateDistortion === 'function') {
            window.AnimationManager.animateDistortion(0.15, 1500, 'menuClose');
        } else if (this.distortionPass) {
            // Fallback animation
            anime({
                targets: this.distortionPass.uniforms.uDistortionAmount,
                value: [0, 0.15, 0],
                duration: 1500,
                easing: 'easeInOutQuad'
            });
        }

        // Hide menu (using AnimationManager if available)
        if (menu && window.AnimationManager && typeof window.AnimationManager.animateMenuOut === 'function') {
            window.AnimationManager.animateMenuOut(menu);
        } else if (menu) {
            // Fallback animation
            anime({
                targets: '.menu nav ul li',
                translateY: [0, -20],
                opacity: [1, 0],
                duration: 400,
                delay: anime.stagger(50, { direction: 'reverse' })
            });

            anime({
                targets: menu,
                opacity: 0,
                duration: 400,
                complete: () => {
                    menu.classList.add('hidden');
                    menu.classList.remove('visible');

                    setTimeout(() => {
                        if (menu) menu.style.opacity = '';
                    }, 100);
                }
            });
        }

        // Animate logo if it exists (using AnimationManager if available)
        if (this.logo && isHomePage()) {
            const initialState = {
                position: this.initialLogoPosition,
                rotation: this.initialLogoRotation
            };

            if (window.AnimationManager && typeof window.AnimationManager.animateLogoForMenuClose === 'function') {
                window.AnimationManager.animateLogoForMenuClose(this.logo, initialState, () => {
                    this.finishMenuClose();
                });
            } else {
                // Fallback animation
                this.animateLogoForMenuCloseFallback(() => {
                    this.finishMenuClose();
                });
            }
        } else {
            // No logo animation needed
            setTimeout(() => {
                this.finishMenuClose();
            }, 500);
        }
    }

    /**
     * Fallback animation for logo when closing menu
     */
    private animateLogoForMenuCloseFallback(onComplete = null) {
        if (!this.logo) return;

        const currentY = this.logo.position.y;
        const initialY = this.initialLogoPosition ? this.initialLogoPosition.y : 0;
        const initialRotationY = this.initialLogoRotation ? this.initialLogoRotation.y : 0;

        const timeline = anime.timeline({
            easing: 'easeInOutQuad'
        });

        timeline
            .add({
                targets: this.logo.position,
                y: currentY + 2,
                duration: 800,
                easing: 'easeOutQuad'
            })
            .add({
                targets: this.logo.rotation,
                y: initialRotationY,
                duration: 1200,
                easing: 'easeInOutQuad'
            }, '-=800')
            .add({
                targets: this.logo.position,
                y: initialY,
                duration: 1000,
                easing: 'easeOutElastic(1, 0.8)',
                complete: () => {
                    if (onComplete) onComplete();
                }
            });
    }

    /**
     * Complete the menu closing process
     */
    private finishMenuClose() {
        this.isTransitioning = false;
        this.isMenuOpen = false;

        // Show continue prompt again if on home page
        if (isHomePage()) {
            this.showContinuePrompt();
        }
    }

    private animate = () => {
        requestAnimationFrame(this.animate);

        const time = this.clock.getElapsedTime();

        // Update shader uniforms with time
        if (this.distortionPass) {
            this.distortionPass.uniforms.uTime.value = time;
        }

        // Update particle animation
        if (this.particles && this.particles.material instanceof THREE.ShaderMaterial) {
            this.particles.material.uniforms.uTime.value = time;
        }

        // Update grid animation
        if (this.gridPlane && this.gridPlane.material instanceof THREE.ShaderMaterial) {
            this.gridPlane.material.uniforms.uTime.value = time;
        }

        if (this.logo) {
            // Apply different animations based on menu state
            if (this.isMenuOpen && !this.isTransitioning) {
                // Menu open animation
                this.logo.rotation.y += 0.0005;
                const pulseIntensity = Math.sin(time * 0.5) * 0.3 + 0.7;
                this.mainBeam.intensity = 120 + (30 * pulseIntensity);
                (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.2 + (0.1 * pulseIntensity);
                (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.15 + (0.05 * pulseIntensity);
                this.scene.fog = new THREE.FogExp2(0x000000, 0.004 + (0.001 * pulseIntensity));

                // Subtle glow animation
                this.logo.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                        child.material.emissiveIntensity = 0.1 + 0.05 * pulseIntensity;
                    }
                });
            } else if (!this.isTransitioning) {
                // Idle state animation
                this.logo.rotation.y += 0.001;
                this.logo.position.y = this.initialLogoPosition ?
                    this.initialLogoPosition.y + Math.sin(time * 0.5) * 0.1 + Math.sin(time * 0.2) * 0.03 :
                    Math.sin(time * 0.5) * 0.1 + Math.sin(time * 0.2) * 0.03;
                this.logo.rotation.x = Math.sin(time * 0.3) * 0.02;
                this.logo.rotation.z = Math.cos(time * 0.2) * 0.02;

                // Balanced intensity for good visibility
                this.mainBeam.intensity = 100;
                (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.18;
                (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.12;
                this.scene.fog = new THREE.FogExp2(0x000000, 0.004);

                // Very subtle breathing effect
                const breatheIntensity = Math.sin(time * 0.4) * 0.1 + 0.9;
                this.logo.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                        child.material.emissiveIntensity = 0.08 + 0.03 * breatheIntensity;
                    }
                });
            }

            // Update environment map periodically for better reflections
            if (Math.floor(time * 10) % 10 === 0) {
                this.updateLogoEnvMap();
            }
        }

        this.composer.render();
    }

    public prepareForTransition() {
        if (!this.logo) return;

        console.log('Preparing for transition');
        this.isTransitioning = true;

        // Set transition direction based on current state
        if (this.isMenuOpen) {
            this.transitionDirection = 'out';
        } else {
            this.transitionDirection = 'in';
        }

        // Use AnimationManager for transition effects if available
        if (window.AnimationManager) {
            if (typeof window.AnimationManager.animateDistortion === 'function') {
                window.AnimationManager.animateDistortion(0.2, 1000, 'transition');
            }

            if (typeof window.AnimationManager.animateLogoForPageTransition === 'function') {
                window.AnimationManager.animateLogoForPageTransition(this.logo, this.transitionDirection, () => {
                    this.resetTransitionState();
                });
                return; // Early return if AnimationManager handles transition
            }
        }

        // Fallback transitions if AnimationManager not available
        if (this.distortionPass) {
            anime({
                targets: this.distortionPass.uniforms.uDistortionAmount,
                value: [0, 0.2, 0],
                duration: 1000,
                easing: 'easeInOutQuad'
            });
        }

        anime.remove(this.logo.position);
        anime.remove(this.logo.rotation);

        // Page transition animation
        if (this.transitionDirection === 'out') {
            anime({
                targets: this.logo.scale,
                x: this.logo.scale.x * 0.8,
                y: this.logo.scale.y * 0.8,
                z: this.logo.scale.z * 0.8,
                duration: 500,
                easing: 'easeInQuad'
            });

            anime({
                targets: this.logo.position,
                y: this.logo.position.y - 2,
                duration: 500,
                easing: 'easeInQuad'
            });
        } else if (this.logo) {  // Fixed TypeScript null check
            anime({
                targets: this.logo.scale,
                x: this.logo.scale.x * 1.2,
                y: this.logo.scale.y * 1.2,
                z: this.logo.scale.z * 1.2,
                duration: 500,
                easing: 'easeOutQuad',
                complete: () => {
                    if (this.logo) {  // Additional null check for callback
                        anime({
                            targets: this.logo.scale,
                            x: this.logo.scale.x / 1.2,
                            y: this.logo.scale.y / 1.2,
                            z: this.logo.scale.z / 1.2,
                            duration: 800,
                            easing: 'easeOutElastic(1, 0.5)'
                        });
                    }
                }
            });
        }

        // Make sure we reset transition state after animation
        setTimeout(() => {
            this.resetTransitionState();
        }, 800);
    }

    public resetTransitionState() {
        console.log('Explicitly resetting transition state from:', this.isTransitioning, 'to false');
        this.isTransitioning = false;

        // Completely reset the menu state if needed
        if (isHomePage()) {
            // On home page, reset menu state
            const menu = document.getElementById('menu');
            if (menu) {
                if (menu.classList.contains('visible')) {
                    this.isMenuOpen = true;
                } else {
                    this.isMenuOpen = false;
                    // Show continue prompt if menu isn't open
                    this.showContinuePrompt();
                }
            }

            // Force event handler reinitialization
            if (window.EventHandler && typeof window.EventHandler.initialize === 'function') {
                console.log('Reinitializing event handlers after navigation');
                window.EventHandler.initialize();
            }
        }
    }

    public handleReturnToHome() {
        console.log('Handling return to home page');

        // Reset critical state flags
        this.isTransitioning = false;
        this.isMenuOpen = false;

        // Reset logo position if needed
        if (this.logo && this.initialLogoPosition && this.initialLogoRotation) {
            // Use AnimationManager to reset if available
            if (window.AnimationManager && typeof window.AnimationManager.resetLogoState === 'function') {
                window.AnimationManager.resetLogoState(this.logo, {
                    position: this.initialLogoPosition,
                    rotation: this.initialLogoRotation
                });
            } else {
                // Cancel any existing animations
                anime.remove(this.logo.position);
                anime.remove(this.logo.rotation);

                // Reset the logo to its initial state
                this.logo.position.copy(this.initialLogoPosition);
                this.logo.rotation.copy(this.initialLogoRotation);
            }

            // Set balanced lighting values for default state
            this.mainBeam.intensity = 100;
            (this.beamMesh.material as THREE.MeshBasicMaterial).opacity = 0.18;
            (this.secondaryBeamMesh.material as THREE.MeshBasicMaterial).opacity = 0.12;
            this.scene.fog = new THREE.FogExp2(0x000000, 0.004);
        }

        // Reset menu state
        const menu = document.getElementById('menu');
        if (menu) {
            // Remove any inline styles that might override CSS transitions
            menu.style.opacity = '';
            menu.classList.remove('visible');
            menu.classList.add('hidden');

            // Also reset menu items to ensure they're ready for the next animation
            const menuItems = menu.querySelectorAll('nav ul li');
            menuItems.forEach(item => {
                (item as HTMLElement).style.opacity = '';
                (item as HTMLElement).style.transform = '';
            });
        }

        // Show continue prompt
        this.showContinuePrompt();

        // Force event handler reinitialization
        if (window.EventHandler && typeof window.EventHandler.initialize === 'function') {
            window.EventHandler.initialize();
        }
    }

    private handleResize = () => {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    private updateLogoEnvMap() {
        if (this.logo && this.cubeCamera && this.cubeRenderTarget) {
            // Temporarily hide the logo for environment capture
            this.logo.visible = false;
            // Update the cube camera
            this.cubeCamera.update(this.renderer, this.scene);
            // Make the logo visible again
            this.logo.visible = true;
            // Update the material's environment map for all meshes in the logo
            this.logo.traverse((child) => {
                if (child instanceof THREE.Mesh && child.material instanceof THREE.MeshPhysicalMaterial) {
                    child.material.envMap = this.cubeRenderTarget?.texture || null;
                }
            });
        }
    }

    private hideLoadingScreen() {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
            loadingScreen.style.opacity = '0';
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500);
        }
    }

    private showContinuePrompt() {
        // Only show on home page
        if (!isHomePage()) return;

        const prompt = document.getElementById('continue-prompt');
        if (!prompt) return;

        prompt.classList.remove('hidden');

        // Use AnimationManager if available
        if (window.AnimationManager && typeof window.AnimationManager.animateContinuePromptIn === 'function') {
            window.AnimationManager.animateContinuePromptIn(prompt);
        } else {
            // Fallback animation
            const text = prompt.textContent || '';
            prompt.innerHTML = text.split('').map(char =>
                char === ' ' ? ' ' : `<span>${char}</span>`
            ).join('');

            anime.timeline({
                easing: 'easeOutElastic(1, 0.8)'
            })
                .add({
                    targets: prompt,
                    opacity: 1,
                    duration: 800
                })
                .add({
                    targets: '#continue-prompt span',
                    translateY: [-20, 0],
                    opacity: [0, 1],
                    delay: anime.stagger(30),
                    duration: 600,
                    complete: () => {
                        prompt.style.opacity = '1';
                    }
                }, '-=400');
        }
    }

    /**
     * Update menu open state
     */
    public setMenuState(isOpen: boolean) {
        this.isMenuOpen = isOpen;
    }
}

// Add these to the Window interface for TypeScript
declare global {
    interface Window {
        AnimationManager?: any;
        AppState?: any;
        EventHandler?: any;
        sceneInstance: any;
        navBackToHome: boolean;
    }
}

================
File: src/css-utils/clamp-generator.js
================
const viewports = require('../design-tokens/viewports.json');

/**
 * Takes an array of tokens and sends back and array of name
 * and clamp pairs for CSS fluid values.
 *
 * @param {array} tokens array of {name: string, min: number, max: number}
 * @returns {array} {name: string, value: string}
 */
const clampGenerator = tokens => {
  const rootSize = 16;

  return tokens.map(({name, min, max}) => {
    if (min === max) {
      return `${min / rootSize}rem`;
    }

    // Convert the min and max sizes to rems
    const minSize = min / rootSize;
    const maxSize = max / rootSize;

    // Convert the pixel viewport sizes into rems
    const minViewport = viewports.min / rootSize;
    const maxViewport = viewports.max / rootSize;

    // Slope and intersection allow us to have a fluid value but also keep that sensible
    const slope = (maxSize - minSize) / (maxViewport - minViewport);
    const intersection = -1 * minViewport * slope + minSize;

    return {
      name,
      value: `clamp(${minSize}rem, ${intersection.toFixed(2)}rem + ${(
        slope * 100
      ).toFixed(2)}vw, ${maxSize}rem)`
    };
  });
};

module.exports = clampGenerator;

================
File: src/css-utils/tokens-to-tailwind.js
================
const slugify = require('slugify');

/**
 * Converts human readable tokens into tailwind config friendly ones
 *
 * @param {array} tokens {name: string, value: any}
 * @return {object} {key, value}
 */
const tokensToTailwind = tokens => {
  const nameSlug = text => slugify(text, {lower: true});
  let response = {};

  tokens.forEach(({name, value}) => {
    response[nameSlug(name)] = value;
  });

  return response;
};

module.exports = tokensToTailwind;

================
File: src/css/blocks/landing.css
================
/* Continue prompt styling with improved animation */
#continue-prompt {
  position: fixed;
  bottom: 2rem;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  font-family: "Rajdhani", sans-serif;
  font-size: 1.4rem;
  font-weight: 500;
  opacity: 0;
  z-index: 100;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  text-shadow:
    0 0 10px rgba(255, 255, 255, 0.5),
    0 0 20px rgba(255, 255, 255, 0.3);
  white-space: nowrap;
  transform-origin: center bottom;
  will-change: opacity, transform;
}

================
File: src/css/blocks/photos.css
================
.photos-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 2rem;
}

.photos-container {
  position: relative;
  z-index: 10;
  padding: 4rem 2rem;
  color: white;
  max-width: 1200px;
  margin: 0 auto;
  opacity: 0;
  animation: fadeIn 0.8s forwards;
  animation-delay: 0.3s;
  will-change: opacity, transform;
}

.photos-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 3rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.photos-header h1 {
  font-family: 'Rajdhani', sans-serif;
  font-size: 3rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  text-shadow: 0 0 15px rgba(255,255,255,0.3),
               0 0 30px rgba(100,149,237,0.3);
  margin: 0;
}
.photo-item {
  position: relative;
  aspect-ratio: 4/3;
  overflow: hidden;
  border-radius: 8px;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
  will-change: transform, box-shadow;
}

.photo-item:hover {
  transform: scale(1.02) translateY(-5px);
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
}

.photo-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: opacity 0.3s ease, transform 0.5s ease;
  will-change: opacity, transform;
}

.photo-item:hover img {
  opacity: 0.9;
  transform: scale(1.05);
}

.photo-caption {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 1rem;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  font-family: 'Outfit', sans-serif;
  font-weight: 500;
  transform: translateY(100%);
  transition: transform 0.3s ease;
  will-change: transform;
}

.photo-item:hover .photo-caption {
  transform: translateY(0);
}

================
File: src/css/blocks/prose.css
================
.prose {
  --flow-space: var(--space-m);
}

================
File: src/css/blocks/test.css
================
/**
 * global.css
 * Main stylesheet with animation fixes and improved transitions
 */

#loading-screen {
  position: fixed;
  width: 100vw;
  height: 100vh;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  transition: opacity 0.5s ease;
}

.loader {
  width: 50px;
  height: 50px;
  border: 5px solid #333;
  border-top-color: #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* 3D Scene container */
#scene-container {
  position: fixed;
  width: 100vw;
  height: 100vh;
  z-index: 1;
  background: #000;
  transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1);
}

/* Main content container */
#page-content {
  position: relative;
  z-index: 5;
  width: 100%;
  min-height: 100vh;
}



/* Pulse animation for continue prompt */
@keyframes glowPulse {
  0%, 100% {
    opacity: 0.7;
    transform: translateX(-50%) scale(0.98);
    text-shadow:
      0 0 10px rgba(255, 255, 255, 0.3),
      0 0 20px rgba(255, 255, 255, 0.2);
  }
  50% {
    opacity: 1;
    transform: translateX(-50%) scale(1);
    text-shadow:
      0 0 15px rgba(255, 255, 255, 0.5),
      0 0 30px rgba(255, 255, 255, 0.3),
      0 0 40px rgba(100, 149, 237, 0.3);
  }
}

#continue-prompt span {
  display: inline-block;
  will-change: opacity, transform;
}

/* Utility class */
.hidden {
  display: none !important;
}

/* === MENU STYLING === */
.menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: rgba(0, 0, 0, 0.8);
  opacity: 0;
  pointer-events: none;
  z-index: 500;
  will-change: opacity;

  /* Remove transition to prevent conflicts with anime.js */
  /* transition property removed intentionally */
}

.menu.visible {
  opacity: 1;
  pointer-events: all;
}

.menu nav {
  position: relative;
  z-index: 2;
}

.menu nav ul {
  list-style: none;
  padding: 0;
  margin: 0;
  text-align: center;
}

.menu nav ul li {
  margin: 2rem 0;
  transform: translateY(0);
  opacity: 1;
  will-change: opacity, transform;

  /* Remove transition to prevent conflicts with anime.js */
  /* transition property removed intentionally */
}

.menu nav ul li a {
  font-family: "Rajdhani", sans-serif;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: white;
  text-decoration: none;
  font-size: 2rem;
  transition: color 0.3s, transform 0.3s;
}

.menu nav ul li a:hover {
  color: #f0f0f0;
  transform: translateY(-2px);
}

.menu nav ul li a.strike {
  text-decoration: line-through;
  opacity: 0.5;
  pointer-events: none;
}

/* === HOME PAGE STYLES === */
.home-content {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  color: white;
  text-align: center;
  padding: 2rem;
  opacity: 0;
  transition: opacity 0.5s ease;
}

.home-content h1 {
  font-family: "Rajdhani", sans-serif;
  font-size: 3rem;
  font-weight: 700;
  margin-bottom: 1rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  text-shadow:
    0 0 15px rgba(255, 255, 255, 0.3),
    0 0 30px rgba(100, 149, 237, 0.3);
}

.home-content p {
  font-family: "Outfit", sans-serif;
  font-size: 1.2rem;
  max-width: 600px;
  margin: 0 auto;
}


.back-button {
  font-family: 'Rajdhani', sans-serif;
  font-size: 1rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: white;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.3);
  padding: 0.6rem 1.2rem;
  border-radius: 4px;
  text-decoration: none;
  transition: all 0.3s ease;
  will-change: transform, box-shadow, background-color;
}

.back-button:hover {
  background: rgba(100, 149, 237, 0.2);
  border-color: rgba(255, 255, 255, 0.5);
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.page-transition-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: #000;
  z-index: 999;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.4s ease;
}

================
File: src/css/components/box.css
================
/*
BOX
More info: https://every-layout.dev/layouts/box/#the-generator
*/

.box {
    background: var(--color-light);
    color: var(--color-dark);
    padding: var(--space-s-m);
  }
  
  .box * {
    color: inherit;
  }
  
  .box.invert {
    background: var(--color-dark);
    color: var(--color-light);
  }

================
File: src/css/components/cluster.css
================
/*
CLUSTER
More info: https://every-layout.dev/layouts/cluster/
A layout that lets you distribute items with consitent
spacing, regardless of their size

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--cluster-horizontal-alignment (flex-start) How items should align
horizontally. Can be any acceptable flexbox aligmnent value.

--cluster-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/

.cluster {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-m));
  justify-content: var(--cluster-horizontal-alignment, flex-start);
  align-items: var(--cluster-vertical-alignment, center);
}

================
File: src/css/components/flow.css
================
/* 
FLOW COMPOSITION 
Like the Every Layout stack: https://every-layout.dev/layouts/stack/
Info about this implementation: https://piccalil.li/quick-tip/flow-utility/ 
*/
.flow > * + * {
  margin-top: var(--flow-space, 1em);
}

================
File: src/css/components/grid.css
================
/* AUTO GRID
Related Every Layout: https://every-layout.dev/layouts/grid/
More info on the flexible nature: https://piccalil.li/tutorial/create-a-responsive-grid-layout-with-no-media-queries-using-css-grid/
A flexible layout that will create an auto-fill grid with
configurable grid item sizes

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--grid-min-item-size (14rem): How large each item should be
ideally, as a minimum.

--grid-placement (auto-fill): Set either auto-fit or auto-fill
to change how empty grid tracks are handled */

.grid {
  display: grid;
  grid-template-columns: repeat(
    var(--grid-placement, auto-fill),
    minmax(var(--grid-min-item-size, 16rem), 1fr)
  );
  gap: var(--gutter, var(--space-s-l));
}

/* A split 50/50 layout */
.grid[data-layout='50-50'] {
  --grid-placement: auto-fit;
  --grid-min-item-size: clamp(16rem, 50vw, 33rem);
}

/* Three column grid layout */
.grid[data-layout='thirds'] {
  --grid-placement: auto-fit;
  --grid-min-item-size: clamp(16rem, 33%, 20rem);
}

/* Twelve column grid layout */
.grid[data-layout='twelfths'] {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
}

/* Special layout for larger devices. Used on home page intro */
.grid[data-layout='lg:10/2'] {
  grid-template-columns: 100%;
}

@media screen(md) {
  .grid[data-layout='lg:10/2'] {
    grid-template-columns: clamp(40rem, 80vw, 60rem);
  }
}

@media screen(lg) {
  .grid[data-layout='lg:10/2'] {
    grid-template-columns: 10fr 2fr;
  }
}

================
File: src/css/components/icon.css
================
/* 
ICON
From Every Layout: https://every-layout.dev/layouts/icon/
*/

.icon {
    width: 0.75em;
    width: 1cap;
    height: 0.75em;
    height: 1cap;
  }
  
  .with-icon {
    display: inline-flex;
    align-items: baseline;
  }
  
  .with-icon .icon {
    margin-inline-end: 1rem;
  }

================
File: src/css/components/repel.css
================
/*
REPEL
A little layout that pushes items away from each other where
there is space in the viewport and stacks on small viewports

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--repel-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/
.repel {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: var(--repel-vertical-alignment, center);
  gap: var(--gutter, var(--space-s-m));
}

.repel[data-nowrap] {
  flex-wrap: nowrap;
}

================
File: src/css/components/sidebar.css
================
/* 
SIDEBAR
More info: https://every-layout.dev/layouts/sidebar/
A layout that allows you to have a flexible main content area
and a "fixed" width sidebar that sits on the left or right.
If there is not enough viewport space to fit both the sidebar
width *and* the main content minimum width, they will stack
on top of each other

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-size-1)): This defines the space
between the sidebar and main content.

--sidebar-target-width (20rem): How large the sidebar should be

--sidebar-content-min-width(50%): The minimum size of the main content area

EXCEPTIONS
.sidebar[data-direction='rtl']: flips the sidebar to be on the right 
*/
.sidebar {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-l));
}

.sidebar > :first-child {
  flex-basis: var(--sidebar-target-width, 20rem);
  flex-grow: 1;
}

.sidebar > :last-child {
  flex-basis: 0;
  flex-grow: 999;
  min-width: var(--sidebar-content-min-width, 50%);
}

================
File: src/css/components/switcher.css
================
/*
SWITCHER
More info: https://every-layout.dev/layouts/switcher/
A layout that allows you to lay **2** items next to each other
until there is not enough horizontal space to allow that.

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-size-1)): This defines the space
between each item

--switcher-target-container-width (40rem): How large the container
needs to be to allow items to sit inline with each other

--switcher-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/
.switcher {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-l));
  align-items: var(--switcher-vertical-alignment, flex-start);
}

.switcher > * {
  flex-grow: 1;
  flex-basis: calc((var(--switcher-target-container-width, 40rem) - 100%) * 999);
}

/* Max 2 items,
so anything greater than 2 is ful width */
.switcher > :nth-child(n + 3) {
  flex-basis: 100%;
}

================
File: src/css/components/wrapper.css
================
/*
WRAPPER COMPOSITION 
A common wrapper/container
*/
.wrapper {
  margin-inline: auto;
  max-width: clamp(16rem, var(--wrapper-max-width, 100vw), 80rem);
  padding-left: var(--gutter);
  padding-right: var(--gutter);
  position: relative;
}

================
File: src/css/global.css
================
@import 'tailwindcss/base';

@import 'global/reset.css';
@import 'global/fonts.css';

@import 'tailwindcss/components';

@import 'global/variables.css';
@import 'global/global-styles.css';
/*
See issue: https://github.com/frankstallone/astro-cube-boilerplate/issues/1
Reference source: https://github.com/Set-Creative-Studio/cube-boilerplate/blob/main/src/css/global.css#L11

@import-glob 'blocks/*.css' layer(components);
@import-glob 'components/*.css' layer(components);
@import-glob 'utilities/*.css' layer(components);
*/

@import 'blocks/prose.css' layer(components);
@import 'blocks/test.css';
@import 'blocks/photos.css';
@import 'blocks/landing.css' layer(components);
@import 'components/box.css' layer(components);
@import 'components/cluster.css' layer(components);
@import 'components/flow.css' layer(components);
@import 'components/grid.css' layer(components);
@import 'components/icon.css' layer(components);
@import 'components/repel.css' layer(components);
@import 'components/sidebar.css' layer(components);
@import 'components/switcher.css' layer(components);
@import 'components/wrapper.css' layer(components);
@import 'utilities/region.css' layer(components);
@import 'utilities/visually-hidden.css' layer(components);

@import 'tailwindcss/utilities';

================
File: src/css/global/fonts.css
================
/* @font-face here */

================
File: src/css/global/global-styles.css
================
/* 
  Global styles 

  Low-specificity, global styles that apply to the whole 
  project: https://cube.fyi/css.html
*/

body {
  background: var(--color-light);
  color: var(--color-dark);
  font-size: var(--size-step-0);
  font-family: var(--font-base);
  line-height: var(--leading-standard);
}

================
File: src/css/global/reset.css
================
/* Modern reset: https://piccalil.li/blog/a-more-modern-css-reset/ */

/* Box sizing rules */
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Prevent font size inflation */
html {
  -moz-text-size-adjust: none;
  -webkit-text-size-adjust: none;
  text-size-adjust: none;
}

/* Remove default margin in favour of better control in authored CSS */
body,
h1,
h2,
h3,
h4,
p,
figure,
blockquote,
dl,
dd {
  margin: 0;
}

/* Remove list styles on ul, ol elements with a list role, which suggests default styling will be removed */
ul[role='list'],
ol[role='list'] {
  list-style: none;
}

/* Set core body defaults */
body {
  min-height: 100vh;
  line-height: 1.5;
}

/* Set shorter line heights on headings and interactive elements */
h1,
h2,
h3,
h4,
button,
input,
label {
  line-height: 1.1;
}

/* Balance text wrapping on headings */
h1,
h2,
h3,
h4 {
  text-wrap: balance;
}

/* A elements that don't have a class get default styles */
a:not([class]) {
  text-decoration-skip-ink: auto;
  color: currentColor;
}

/* Make images easier to work with */
img,
picture {
  max-width: 100%;
  display: block;
}

/* Inherit fonts for inputs and buttons */
input,
button,
textarea,
select {
  font: inherit;
}

/* Make sure textareas without a rows attribute are not tiny */
textarea:not([rows]) {
  min-height: 10em;
}

/* Anything that has been anchored to should have extra scroll margin */
:target {
  scroll-margin-block: 5ex;
}

================
File: src/css/global/variables.css
================
:root {
  --gutter: var(--space-s-l);
  --transition-base: 250ms ease;
  --transition-movement: 200ms linear;
  --transition-fade: 300ms ease;
  --transition-bounce: 500ms cubic-bezier(0.5, 0.05, 0.2, 1.5);
  --leading-standard: 1.5;
}

================
File: src/css/repopack-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-03T17:44:13.940Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
blocks/prose.css
components/box.css
components/cluster.css
components/flow.css
components/grid.css
components/icon.css
components/repel.css
components/sidebar.css
components/switcher.css
components/wrapper.css
global.css
global/fonts.css
global/global-styles.css
global/reset.css
global/variables.css
utilities/region.css
utilities/visually-hidden.css

================================================================
Repository Files
================================================================

================
File: blocks/prose.css
================
.prose {
  --flow-space: var(--space-m);
}

================
File: components/box.css
================
/*
BOX
More info: https://every-layout.dev/layouts/box/#the-generator
*/

.box {
    background: var(--color-light);
    color: var(--color-dark);
    padding: var(--space-s-m);
  }
  
  .box * {
    color: inherit;
  }
  
  .box.invert {
    background: var(--color-dark);
    color: var(--color-light);
  }

================
File: components/cluster.css
================
/*
CLUSTER
More info: https://every-layout.dev/layouts/cluster/
A layout that lets you distribute items with consitent
spacing, regardless of their size

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--cluster-horizontal-alignment (flex-start) How items should align
horizontally. Can be any acceptable flexbox aligmnent value.

--cluster-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/

.cluster {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-m));
  justify-content: var(--cluster-horizontal-alignment, flex-start);
  align-items: var(--cluster-vertical-alignment, center);
}

================
File: components/flow.css
================
/* 
FLOW COMPOSITION 
Like the Every Layout stack: https://every-layout.dev/layouts/stack/
Info about this implementation: https://piccalil.li/quick-tip/flow-utility/ 
*/
.flow > * + * {
  margin-top: var(--flow-space, 1em);
}

================
File: components/grid.css
================
/* AUTO GRID
Related Every Layout: https://every-layout.dev/layouts/grid/
More info on the flexible nature: https://piccalil.li/tutorial/create-a-responsive-grid-layout-with-no-media-queries-using-css-grid/
A flexible layout that will create an auto-fill grid with
configurable grid item sizes

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--grid-min-item-size (14rem): How large each item should be
ideally, as a minimum.

--grid-placement (auto-fill): Set either auto-fit or auto-fill
to change how empty grid tracks are handled */

.grid {
  display: grid;
  grid-template-columns: repeat(
    var(--grid-placement, auto-fill),
    minmax(var(--grid-min-item-size, 16rem), 1fr)
  );
  gap: var(--gutter, var(--space-s-l));
}

/* A split 50/50 layout */
.grid[data-layout='50-50'] {
  --grid-placement: auto-fit;
  --grid-min-item-size: clamp(16rem, 50vw, 33rem);
}

/* Three column grid layout */
.grid[data-layout='thirds'] {
  --grid-placement: auto-fit;
  --grid-min-item-size: clamp(16rem, 33%, 20rem);
}

/* Twelve column grid layout */
.grid[data-layout='twelfths'] {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
}

/* Special layout for larger devices. Used on home page intro */
.grid[data-layout='lg:10/2'] {
  grid-template-columns: 100%;
}

@media screen(md) {
  .grid[data-layout='lg:10/2'] {
    grid-template-columns: clamp(40rem, 80vw, 60rem);
  }
}

@media screen(lg) {
  .grid[data-layout='lg:10/2'] {
    grid-template-columns: 10fr 2fr;
  }
}

================
File: components/icon.css
================
/* 
ICON
From Every Layout: https://every-layout.dev/layouts/icon/
*/

.icon {
    width: 0.75em;
    width: 1cap;
    height: 0.75em;
    height: 1cap;
  }
  
  .with-icon {
    display: inline-flex;
    align-items: baseline;
  }
  
  .with-icon .icon {
    margin-inline-end: 1rem;
  }

================
File: components/repel.css
================
/*
REPEL
A little layout that pushes items away from each other where
there is space in the viewport and stacks on small viewports

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-s-m)): This defines the space
between each item.

--repel-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/
.repel {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: var(--repel-vertical-alignment, center);
  gap: var(--gutter, var(--space-s-m));
}

.repel[data-nowrap] {
  flex-wrap: nowrap;
}

================
File: components/sidebar.css
================
/* 
SIDEBAR
More info: https://every-layout.dev/layouts/sidebar/
A layout that allows you to have a flexible main content area
and a "fixed" width sidebar that sits on the left or right.
If there is not enough viewport space to fit both the sidebar
width *and* the main content minimum width, they will stack
on top of each other

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-size-1)): This defines the space
between the sidebar and main content.

--sidebar-target-width (20rem): How large the sidebar should be

--sidebar-content-min-width(50%): The minimum size of the main content area

EXCEPTIONS
.sidebar[data-direction='rtl']: flips the sidebar to be on the right 
*/
.sidebar {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-l));
}

.sidebar > :first-child {
  flex-basis: var(--sidebar-target-width, 20rem);
  flex-grow: 1;
}

.sidebar > :last-child {
  flex-basis: 0;
  flex-grow: 999;
  min-width: var(--sidebar-content-min-width, 50%);
}

================
File: components/switcher.css
================
/*
SWITCHER
More info: https://every-layout.dev/layouts/switcher/
A layout that allows you to lay **2** items next to each other
until there is not enough horizontal space to allow that.

CUSTOM PROPERTIES AND CONFIGURATION
--gutter (var(--space-size-1)): This defines the space
between each item

--switcher-target-container-width (40rem): How large the container
needs to be to allow items to sit inline with each other

--switcher-vertical-alignment How items should align vertically.
Can be any acceptable flexbox alignment value.
*/
.switcher {
  display: flex;
  flex-wrap: wrap;
  gap: var(--gutter, var(--space-s-l));
  align-items: var(--switcher-vertical-alignment, flex-start);
}

.switcher > * {
  flex-grow: 1;
  flex-basis: calc((var(--switcher-target-container-width, 40rem) - 100%) * 999);
}

/* Max 2 items,
so anything greater than 2 is ful width */
.switcher > :nth-child(n + 3) {
  flex-basis: 100%;
}

================
File: components/wrapper.css
================
/*
WRAPPER COMPOSITION 
A common wrapper/container
*/
.wrapper {
  margin-inline: auto;
  max-width: clamp(16rem, var(--wrapper-max-width, 100vw), 80rem);
  padding-left: var(--gutter);
  padding-right: var(--gutter);
  position: relative;
}

================
File: global.css
================
@import 'tailwindcss/base';

@import 'global/reset.css';
@import 'global/fonts.css';

@import 'tailwindcss/components';

@import 'global/variables.css';
@import 'global/global-styles.css';
/*
See issue: https://github.com/frankstallone/astro-cube-boilerplate/issues/1
Reference source: https://github.com/Set-Creative-Studio/cube-boilerplate/blob/main/src/css/global.css#L11

@import-glob 'blocks/*.css' layer(components);
@import-glob 'components/*.css' layer(components);
@import-glob 'utilities/*.css' layer(components);
*/

@import 'blocks/prose.css' layer(components);
@import 'blocks/test.css' layer(components);
@import 'components/box.css' layer(components);
@import 'components/cluster.css' layer(components);
@import 'components/flow.css' layer(components);
@import 'components/grid.css' layer(components);
@import 'components/icon.css' layer(components);
@import 'components/repel.css' layer(components);
@import 'components/sidebar.css' layer(components);
@import 'components/switcher.css' layer(components);
@import 'components/wrapper.css' layer(components);
@import 'utilities/region.css' layer(components);
@import 'utilities/visually-hidden.css' layer(components);

@import 'tailwindcss/utilities';

================
File: global/fonts.css
================
/* @font-face here */

================
File: global/global-styles.css
================
/* 
  Global styles 

  Low-specificity, global styles that apply to the whole 
  project: https://cube.fyi/css.html
*/

body {
  background: var(--color-light);
  color: var(--color-dark);
  font-size: var(--size-step-0);
  font-family: var(--font-base);
  line-height: var(--leading-standard);
}

================
File: global/reset.css
================
/* Modern reset: https://piccalil.li/blog/a-more-modern-css-reset/ */

/* Box sizing rules */
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Prevent font size inflation */
html {
  -moz-text-size-adjust: none;
  -webkit-text-size-adjust: none;
  text-size-adjust: none;
}

/* Remove default margin in favour of better control in authored CSS */
body,
h1,
h2,
h3,
h4,
p,
figure,
blockquote,
dl,
dd {
  margin: 0;
}

/* Remove list styles on ul, ol elements with a list role, which suggests default styling will be removed */
ul[role='list'],
ol[role='list'] {
  list-style: none;
}

/* Set core body defaults */
body {
  min-height: 100vh;
  line-height: 1.5;
}

/* Set shorter line heights on headings and interactive elements */
h1,
h2,
h3,
h4,
button,
input,
label {
  line-height: 1.1;
}

/* Balance text wrapping on headings */
h1,
h2,
h3,
h4 {
  text-wrap: balance;
}

/* A elements that don't have a class get default styles */
a:not([class]) {
  text-decoration-skip-ink: auto;
  color: currentColor;
}

/* Make images easier to work with */
img,
picture {
  max-width: 100%;
  display: block;
}

/* Inherit fonts for inputs and buttons */
input,
button,
textarea,
select {
  font: inherit;
}

/* Make sure textareas without a rows attribute are not tiny */
textarea:not([rows]) {
  min-height: 10em;
}

/* Anything that has been anchored to should have extra scroll margin */
:target {
  scroll-margin-block: 5ex;
}

================
File: global/variables.css
================
:root {
  --gutter: var(--space-s-l);
  --transition-base: 250ms ease;
  --transition-movement: 200ms linear;
  --transition-fade: 300ms ease;
  --transition-bounce: 500ms cubic-bezier(0.5, 0.05, 0.2, 1.5);
  --leading-standard: 1.5;
}

================
File: utilities/region.css
================
/* 
REGION UTILITY
Consistent block padding for page sections
*/
.region {
  padding-block: var(--region-space, var(--space-xl-2xl));
}

================
File: utilities/visually-hidden.css
================
/* 
VISUALLY HIDDEN UTILITY
Info: https://piccalil.li/quick-tip/visually-hidden/ 
*/
.visually-hidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 0;
  margin: 0;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
  white-space: nowrap;
}

================
File: src/css/utilities/fade-in.css
================
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

================
File: src/css/utilities/region.css
================
/* 
REGION UTILITY
Consistent block padding for page sections
*/
.region {
  padding-block: var(--region-space, var(--space-xl-2xl));
}

================
File: src/css/utilities/visually-hidden.css
================
/* 
VISUALLY HIDDEN UTILITY
Info: https://piccalil.li/quick-tip/visually-hidden/ 
*/
.visually-hidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 0;
  margin: 0;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
  white-space: nowrap;
}

================
File: src/design-tokens/colors.json
================
{
  "title": "Colors",
  "description": "Hex color codes that can be shared, cross-platform. They can be converted at point of usage, such as HSL for web or CMYK for print.",
  "items": [
    {
      "name": "Transparent",
      "value": "transparent"
    },
    {
      "name": "Dark",
      "value": "#030303"
    },
    {
      "name": "Light",
      "value": "#ffffff"
    },
    {
      "name": "Primary",
      "value": "#02394A"
    }
  ]
}

================
File: src/design-tokens/fonts.json
================
{
  "title": "Fonts",
  "description": "Each array of fonts creates a priority-based order. The first font in the array should be the ideal font, followed by sensible, web-safe fallbacks",
  "items": [
    {
      "name": "Base",
      "description": "Primary font for paragraph content in home sections.",
      "value": ["Outfit", "Segoe UI", "Roboto", "Helvetica Neue", "Arial", "sans-serif"]
    },
    {
      "name": "Secondary",
      "description": "Secondary font for paragraph content in home sections.",
      "value": ["Rajdhani", "Segoe UI", "Arial", "sans-serif"]
    }
  ]
}

================
File: src/design-tokens/spacing.json
================
{
  "title": "Spacing",
  "description": "Consistent spacing sizes, based on a ratio, with min and max sizes. This allows you to set spacing based on the context size. For example, min for mobile and max for desktop browsers.",
  "meta": {
    "scaleGenerator": "https://utopia.fyi/space/calculator/?c=330,18,1.2,1200,24,1.25,6,2,&s=0.75|0.5|0.25,1.5|2|3|4|6|8,s-l|s-xl&g=s,l,xl,12"
  },
  "items": [
    {
      "name": "Zero",
      "min": 0,
      "max": 1
    },
    {
      "name": "3XS",
      "min": 5,
      "max": 6
    },
    {
      "name": "2XS",
      "min": 9,
      "max": 12
    },
    {
      "name": "XS",
      "min": 14,
      "max": 18
    },
    {
      "name": "S",
      "min": 18,
      "max": 24
    },
    {
      "name": "M",
      "min": 27,
      "max": 36
    },
    {
      "name": "L",
      "min": 36,
      "max": 48
    },
    {
      "name": "XL",
      "min": 54,
      "max": 72
    },
    {
      "name": "2XL",
      "min": 72,
      "max": 96
    },
    {
      "name": "3XL",
      "min": 108,
      "max": 144
    },
    {
      "name": "4XL",
      "min": 144,
      "max": 192
    },
    {
      "name": "3XS - 2XS",
      "min": 5,
      "max": 12
    },
    {
      "name": "2XS - XS",
      "min": 9,
      "max": 18
    },
    {
      "name": "XS - S",
      "min": 14,
      "max": 24
    },
    {
      "name": "S - M",
      "min": 18,
      "max": 36
    },
    {
      "name": "M - L",
      "min": 27,
      "max": 48
    },
    {
      "name": "L - XL",
      "min": 36,
      "max": 72
    },
    {
      "name": "XL - 2XL",
      "min": 54,
      "max": 96
    },
    {
      "name": "2XL - 3XL",
      "min": 72,
      "max": 144
    },
    {
      "name": "3XL - 4XL",
      "min": 108,
      "max": 192
    },
    {
      "name": "S - L",
      "min": 18,
      "max": 48
    },
    {
      "name": "S - XL",
      "min": 18,
      "max": 72
    }
  ]
}

================
File: src/design-tokens/text-leading.json
================
{
  "title": "Leading",
  "description": "Ratio-based leading/line-height values",
  "items": [
    {
      "name": "Flat",
      "value": 1
    },
    {
      "name": "Fine",
      "value": 1.15
    },
    {
      "name": "Standard",
      "value": 1.5
    },
    {
      "name": "Loose",
      "value": 1.7
    }
  ]
}

================
File: src/design-tokens/text-sizes.json
================
{
  "title": "Text Sizes",
  "description": "A minimum and maximum text size size allows you to pick the right size from a ratio, depending on the context size. The min and max sizes are in pixels and should be converted to appropiate sizes, per context. For example, for web, the should be converted to REM units (pixelSize / baseSize)",
  "meta": {
    "scaleGenerator": "https://utopia.fyi/type/calculator/?c=330,18,1.175,1200,24,1.25,7,1,&s=0.75%7C0.5%7C0.25,1.5%7C2%7C3%7C4%7C6,s-l&g=s,l,xl,12"
  },
  "items": [
    {
      "name": "Step 000",
      "min": 12,
      "max": 14
    },
    {
      "name": "Step 00",
      "min": 15,
      "max": 16
    },
    {
      "name": "Step 0",
      "min": 18,
      "max": 20
    },
    {
      "name": "Step 1",
      "min": 21.6,
      "max": 25
    },
    {
      "name": "Step 2",
      "min": 25.92,
      "max": 31.25
    },
    {
      "name": "Step 3",
      "min": 31.1,
      "max": 39.06
    },
    {
      "name": "Step 4",
      "min": 39.06,
      "max": 48.83
    },
    {
      "name": "Step 5",
      "min": 44.79,
      "max": 61.04
    }
  ]
}

================
File: src/design-tokens/text-weights.json
================
{
  "title": "Text Weights",
  "description": "Helper classes and custom properties for common font weights",
  "meta": {},
  "items": [
    {
      "name": "Regular",
      "value": 400
    },
    {
      "name": "Medium",
      "value": 500
    },
    {
      "name": "Bold",
      "value": 700
    }
  ]
}

================
File: src/design-tokens/viewports.json
================
{
  "title": "Viewports",
  "description": "The min and maximum viewports used to generate fluid type and space scales.",
  "min": 330,
  "mid": 760,
  "max": 1230
}

================
File: src/env.d.ts
================
/// <reference types="astro/client" />

================
File: src/layouts/Layout.astro
================
---
import "../css/global.css";
import { ClientRouter } from "astro:transitions";
interface Props {
  title: string;
}
const { title } = Astro.props;
---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="Thrifted streetwear shop" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap"
      rel="stylesheet"
    />
    <title>{title}</title>
    <ClientRouter />
  </head>
  <body>
    <!-- Loading screen -->
    <div id="loading-screen" transition:persist>
      <div class="loader"></div>
    </div>

    <!-- Three.js scene container -->
    <div id="scene-container" transition:persist>
      <!-- Three.js canvas will be inserted here -->
    </div>

    <!-- Continue prompt -->
    <div id="continue-prompt" class="hidden" transition:persist>
      Press Space or Click Logo to Continue
    </div>

    <!-- Menu overlay -->
    <div id="menu" class="menu hidden" transition:persist>
      <nav>
        <ul>
          <li><a href="#" class="strike">Nowa kolekcja</a></li>
          <li><a href="/photos">ZdjÄ™cia</a></li>
          <li><a href="#posters">Plakaty</a></li>
          <li><a href="#items">Itemy</a></li>
        </ul>
      </nav>
    </div>

    <!-- Page content container -->
    <main id="page-content">
      <slot />
    </main>

    <script>
      import { EventHandler } from "../utils/EventHandler";
      import { Scene } from "../components/Scene";
      import { AppState, APP_STATES } from "../utils/AppState";
      import { UIManager } from "../utils/UIManager";

      // Ensure we have global type declarations
      if (typeof window !== "undefined") {
        window.sceneInstance = window.sceneInstance || null;
        window.navBackToHome = window.navBackToHome || false;
      }

      // Initialize the site when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        console.log("DOM ready, initializing application");

        // Initialize scene first
        initScene();

        // Then initialize state management and event handlers
        AppState.initialize();
        EventHandler.initialize();
        UIManager.initialize();

        // Enable debug mode for development
        const isDevMode = window.location.hostname === 'localhost' ||
                        window.location.hostname === '127.0.0.1';
        if (isDevMode) {
          AppState.setDebugMode(true);
          EventHandler.setDebugMode(true);
          UIManager.setDebugMode(true);
        }
      });

      // Create the 3D scene
      function initScene() {
        const container = document.getElementById("scene-container");
        if (container && !document.querySelector("#scene-container canvas")) {
          console.log("Creating new Scene instance");
          new Scene(container); // Scene registers itself as window.sceneInstance
        }
      }

      // Handle page transitions
      document.addEventListener("astro:before-preparation", (e) => {
        console.log("Preparing for navigation to:", e.to);

        // Detect navigation direction
        const isNavigatingToHome = e.to === '/' || e.to.pathname.endsWith('/');
        const isLeavingHomePage = window.location.pathname === '/' ||
                                window.location.pathname === '';

        // Prepare UI for transition
        if (UIManager) {
          UIManager.handlePageTransition(true, isLeavingHomePage);
        }

        // Prepare AppState for transition
        if (isNavigatingToHome && !isLeavingHomePage) {
          AppState.prepareForTransition(true);
        } else if (isLeavingHomePage) {
          AppState.prepareForTransition(false);
        }
      });

      document.addEventListener("astro:before-navigation", () => {
        // Additional preparation before navigation starts
        if (AppState.isTransitioning) {
          console.log("Cleaning up animations before navigation");
        }
      });

      document.addEventListener("astro:after-navigation", () => {
        // Flag for back-to-home navigation detection
        const isBackToHome = window.navBackToHome &&
                          (window.location.pathname === "/" ||
                           window.location.pathname === "");

        if (isBackToHome && window.sceneInstance) {
          // Use the special back-to-home handler
          if (typeof window.sceneInstance.handleReturnToHome === "function") {
            window.sceneInstance.handleReturnToHome();
          } else {
            // Fallback to regular reset
            window.sceneInstance.resetTransitionState();
          }

          // Reset the flag
          window.navBackToHome = false;
        } else if (window.sceneInstance) {
          // Regular navigation reset
          window.sceneInstance.resetTransitionState();
        }

        // Update UI for the new page
        if (UIManager) {
          const isHomePage = window.location.pathname === '/' ||
                           window.location.pathname === '';
          UIManager.handlePageTransition(false, isHomePage);
        }
      });

      document.addEventListener("astro:page-load", () => {
        console.log("Page fully loaded, ensuring handlers are active");

        // Always reinitialize event handlers after page load
        if (typeof EventHandler.initialize === "function") {
          EventHandler.initialize();
        }

        // Enforce correct UI state
        if (UIManager) {
          UIManager.enforceCorrectUIState(AppState);
        }

        // Force a final state reset on the scene
        if (window.sceneInstance) {
          const isHomePage = window.location.pathname === "/" ||
                           window.location.pathname === "";

          if (isHomePage) {
            console.log("Home page loaded - ensuring proper state");

            // Make sure everything is properly initialized
            setTimeout(() => {
              if (typeof EventHandler.initialize === "function") {
                EventHandler.initialize();
              }

              if (window.sceneInstance) {
                window.sceneInstance.resetTransitionState();
              }

              if (UIManager) {
                UIManager.enforceCorrectUIState(AppState);
              }
            }, 100);
          }
        }
      });
    </script>
  </body>
</html>

================
File: src/pages/index.astro
================
---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Thrifted streetwear shop">
  <div class="home-content">
    <!-- Home page content can be added here when menu is open -->
  </div>
</Layout>

<script>
  import { AppState, APP_STATES } from "../utils/AppState";
  import { EventHandler } from "../utils/EventHandler";

  document.addEventListener("DOMContentLoaded", () => {
    // Initialize back button handling
    EventHandler.initializeBackButton();

    // Ensure we're in the correct state on the home page
    if (AppState.isHomePage()) {
      // Reset any stored transition state
      AppState.resetSceneTransitionState();

      // Transition to proper state if needed
      if (AppState.currentState === APP_STATES.INITIALIZING) {
        setTimeout(() => {
          AppState.transitionTo(APP_STATES.IDLE);
        }, 500);
      }
    }
  });
</script>

================
File: src/pages/photos.astro
================
---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Photos | Thrifted streetwear shop">
  <div class="photos-container wrapper">
    <div class="photos-header">
      <h1>Photo Gallery</h1>
      <a href="/" class="back-button" id="back-to-home">Back to Home</a>
    </div>
    <div class="photos-grid">
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149569710.jpg?t=st=1740863882~exp=1740867482~hmac=6e3d92db1518edc3a4d0b5b5a35aa3a7a19ed441fa85dab3d2affb7697539349&w=740" alt="Fantasy cards" />
        <div class="photo-caption">Fantasy Collection</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-matisse-style-illustration_23-2149587976.jpg?t=st=1740862298~exp=1740865898~hmac=b864d9a601321fc767eee479f266893401ee4d2df748a8a0b8099b64be36fe39&w=740" alt="Card game" />
        <div class="photo-caption">Tournament Series</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/abstract-female-portrait-made-different-shapes_23-2149126821.jpg?t=st=1740863207~exp=1740866807~hmac=76d19808c0afa3df81c0741231ff6f09b45eecbe73caaf3082dbbfcf4cd3bbcb&w=740" alt="Trading cards" />
        <div class="photo-caption">Limited Edition</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-picasso-style-illustration_23-2149602595.jpg?t=st=1740863890~exp=1740867490~hmac=019c3c6037c207bf001290e43da83e06b5ab075fb1f38c8357923e6b554552ac&w=1060" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/hand-drawn-flat-abstract-shapes-collection_23-2149085348.jpg?t=st=1740863893~exp=1740867493~hmac=3719b5d78cd491929bc8275ed968419491b209f122ea53f33820c04f90e1c489&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
      <div class="photo-item">
        <img src="https://img.freepik.com/free-vector/flat-design-geometric-pattern-illustration_23-2150010041.jpg?t=st=1740863897~exp=1740867497~hmac=71cd7c54211a7809daec097a498c20e1aa307b794959936f53e99964f678c3bc&w=740" alt="Game night" />
        <div class="photo-caption">Game Night</div>
      </div>
    </div>
  </div>
</Layout>

<script>
import { AppState, APP_STATES } from '../utils/AppState';
import { EventHandler } from '../utils/EventHandler';
import { UIManager } from '../utils/UIManager';

document.addEventListener('DOMContentLoaded', () => {
  // Initialize back button handling
  EventHandler.initializeBackButton();

  // Set correct app state for subpage
  if (!AppState.isHomePage()) {
    AppState.transitionTo(APP_STATES.SUBPAGE);

    // Add a small delay before showing content
    setTimeout(() => {
      const container = document.querySelector('.photos-container');
      if (container) {
        container.style.opacity = '1';
      }
    }, 300);
  }
});
</script>

================
File: src/types/global.d.ts
================
/**
 * Global type declarations for the application
 */

interface Window {
    sceneInstance: any;
    navBackToHome: boolean;
    EventHandler?: any;
  }

================
File: src/utils/AnimationManager.js
================
/**
 * AnimationManager.js
 * Centralized animation management for the application
 * Handles all animations to ensure consistency and prevent conflicts
 */
import anime from 'animejs/lib/anime.es.js';

class AnimationManagerClass {
  constructor() {
    // Store active animations for proper cleanup
    this._activeAnimations = new Map();

    // Animation timing configurations
    this.timings = {
      menuItemStagger: 80,
      distortionDuration: 1500,
      logoRotationDuration: 1200,
      promptFadeOutDuration: 600,
      menuFadeInDuration: 400,
      menuFadeOutDuration: 400
    };
  }

  /**
   * Clear all active animations or a specific group
   * @param {string} groupId - Optional group ID to clear
   */
  clearAnimations(groupId = null) {
    if (groupId && this._activeAnimations.has(groupId)) {
      // Clear specific animation group
      const animations = this._activeAnimations.get(groupId);
      console.log(`[AnimationManager] Clearing ${animations.length} animations in group '${groupId}'`);

      animations.forEach(anim => {
        if (anim && typeof anim.pause === 'function') {
          anim.pause();
        }
      });

      this._activeAnimations.delete(groupId);
    } else if (!groupId) {
      // Clear all animations
      console.log(`[AnimationManager] Clearing all animations from ${this._activeAnimations.size} groups`);

      this._activeAnimations.forEach(animations => {
        animations.forEach(anim => {
          if (anim && typeof anim.pause === 'function') {
            anim.pause();
          }
        });
      });

      this._activeAnimations.clear();
    }
  }

  /**
   * Add animation to tracking
   * @param {string} groupId - Group identifier for the animation
   * @param {Object} animation - AnimeJS animation instance
   */
  _trackAnimation(groupId, animation) {
    if (!this._activeAnimations.has(groupId)) {
      this._activeAnimations.set(groupId, []);
    }

    this._activeAnimations.get(groupId).push(animation);
    return animation;
  }

  /**
   * Animate distortion effect for transitions
   * @param {number} amount - Max distortion amount (0-1)
   * @param {number} duration - Animation duration in ms
   * @param {string} groupId - Animation group identifier
   */
  animateDistortion(amount, duration, groupId = 'distortion') {
    const sceneInstance = window.sceneInstance;

    if (sceneInstance && sceneInstance.distortionPass) {
      console.log(`[AnimationManager] Animating distortion effect: ${amount}`);

      const animation = anime({
        targets: sceneInstance.distortionPass.uniforms.uDistortionAmount,
        value: [0, amount, 0],
        duration: duration,
        easing: 'easeInOutQuad'
      });

      return this._trackAnimation(groupId, animation);
    }

    return null;
  }

  /**
   * Show menu with animation
   * @param {HTMLElement} menu - The menu element
   * @param {Function} onComplete - Callback when animation completes
   */
  animateMenuIn(menu, onComplete = null) {
    if (!menu) return null;

    console.log('[AnimationManager] Animating menu in');
    this.clearAnimations('menu');

    // Prepare menu for animation
    menu.classList.remove('hidden');
    menu.classList.add('visible');

    // Reset inline styles that might interfere
    menu.style.opacity = '';

    // Reset menu items for animation
    const menuItems = menu.querySelectorAll('nav ul li');
    menuItems.forEach(item => {
      item.style.opacity = '0';
      item.style.transform = 'translateY(20px)';
    });

    // Animate menu items
    const animation = anime({
      targets: '.menu nav ul li',
      translateY: [20, 0],
      opacity: [0, 1],
      duration: 600,
      delay: anime.stagger(this.timings.menuItemStagger),
      easing: 'easeOutQuad',
      complete: () => {
        if (onComplete) onComplete();
      }
    });

    return this._trackAnimation('menu', animation);
  }

  /**
   * Hide menu with animation
   * @param {HTMLElement} menu - The menu element
   * @param {Function} onComplete - Callback when animation completes
   */
  animateMenuOut(menu, onComplete = null) {
    if (!menu) return null;

    console.log('[AnimationManager] Animating menu out');
    this.clearAnimations('menu');

    // Animate menu items out first
    const menuItems = anime({
      targets: '.menu nav ul li',
      translateY: [0, -20],
      opacity: [1, 0],
      duration: 400,
      delay: anime.stagger(50, { direction: 'reverse' }),
      easing: 'easeOutQuad'
    });

    this._trackAnimation('menu', menuItems);

    // Then fade out the menu background
    const menuBg = anime({
      targets: menu,
      opacity: 0,
      duration: this.timings.menuFadeOutDuration,
      easing: 'easeOutQuad',
      complete: () => {
        menu.classList.add('hidden');
        menu.classList.remove('visible');

        // Schedule cleanup of inline styles
        setTimeout(() => {
          if (menu) menu.style.opacity = '';

          // Reset menu items for next animation
          const items = menu.querySelectorAll('nav ul li');
          items.forEach(item => {
            item.style.opacity = '';
            item.style.transform = '';
          });
        }, 100);

        if (onComplete) onComplete();
      }
    });

    return this._trackAnimation('menu', menuBg);
  }

  /**
   * Animate logo for menu opening
   * @param {THREE.Group} logo - The 3D logo object
   * @param {Function} onComplete - Callback when animation completes
   */
  animateLogoForMenuOpen(logo, onComplete = null) {
    if (!logo) return null;

    console.log('[AnimationManager] Animating logo for menu open');
    this.clearAnimations('logo');

    // Store current position for reference
    const currentY = logo.position.y;

    // Create animation timeline
    const timeline = anime.timeline({
      easing: 'easeInOutQuad'
    });

    timeline
      // Move logo up with rotation
      .add({
        targets: logo.position,
        y: currentY + 3,
        duration: 1200,
        easing: 'easeOutQuad'
      })
      .add({
        targets: logo.rotation,
        y: Math.PI * 3,
        duration: this.timings.logoRotationDuration,
        easing: 'easeInOutQuad'
      }, '-=1200')
      // Move logo down with bounce
      .add({
        targets: logo.position,
        y: currentY - 1,
        duration: 800,
        easing: 'easeOutBounce'
      })
      .add({
        targets: logo.rotation,
        y: Math.PI * 4,
        duration: 1000,
        easing: 'easeOutQuad',
        complete: () => {
          if (onComplete) onComplete();
        }
      }, '-=800');

    return this._trackAnimation('logo', timeline);
  }

  /**
   * Animate logo for menu closing
   * @param {THREE.Group} logo - The 3D logo object
   * @param {Object} initialState - Initial logo state {position, rotation}
   * @param {Function} onComplete - Callback when animation completes
   */
  animateLogoForMenuClose(logo, initialState, onComplete = null) {
    if (!logo) return null;

    console.log('[AnimationManager] Animating logo for menu close');
    this.clearAnimations('logo');

    // Get values for animation
    const currentY = logo.position.y;
    const initialY = initialState.position ? initialState.position.y : 0;
    const initialRotationY = initialState.rotation ? initialState.rotation.y : 0;

    // Create animation timeline
    const timeline = anime.timeline({
      easing: 'easeInOutQuad'
    });

    timeline
      // Move logo up
      .add({
        targets: logo.position,
        y: currentY + 2,
        duration: 800,
        easing: 'easeOutQuad'
      })
      // Rotate logo back to initial rotation
      .add({
        targets: logo.rotation,
        y: initialRotationY,
        duration: this.timings.logoRotationDuration,
        easing: 'easeInOutQuad'
      }, '-=800')
      // Move logo to initial position with elastic effect
      .add({
        targets: logo.position,
        y: initialY,
        duration: 1000,
        easing: 'easeOutElastic(1, 0.8)',
        complete: () => {
          if (onComplete) onComplete();
        }
      });

    return this._trackAnimation('logo', timeline);
  }

  /**
   * Animate logo for page transition
   * @param {THREE.Group} logo - The 3D logo object
   * @param {string} direction - Transition direction ('in' or 'out')
   * @param {Function} onComplete - Callback when animation completes
   */
  animateLogoForPageTransition(logo, direction, onComplete = null) {
    if (!logo) return null;

    console.log(`[AnimationManager] Animating logo for page transition: ${direction}`);
    this.clearAnimations('logo');

    // Clear any existing position/rotation animations
    anime.remove(logo.position);
    anime.remove(logo.rotation);

    if (direction === 'out') {
      // Scale down and move down when leaving
      const scaleAnim = anime({
        targets: logo.scale,
        x: logo.scale.x * 0.8,
        y: logo.scale.y * 0.8,
        z: logo.scale.z * 0.8,
        duration: 500,
        easing: 'easeInQuad'
      });

      const posAnim = anime({
        targets: logo.position,
        y: logo.position.y - 2,
        duration: 500,
        easing: 'easeInQuad',
        complete: () => {
          if (onComplete) onComplete();
        }
      });

      this._trackAnimation('logo', scaleAnim);
      return this._trackAnimation('logo', posAnim);
    } else {
      // Scale up and bounce when entering
      return this._trackAnimation('logo', anime({
        targets: logo.scale,
        x: logo.scale.x * 1.2,
        y: logo.scale.y * 1.2,
        z: logo.scale.z * 1.2,
        duration: 500,
        easing: 'easeOutQuad',
        complete: () => {
          if (logo) {
            // Scale back down with elastic effect
            const bounceAnim = anime({
              targets: logo.scale,
              x: logo.scale.x / 1.2,
              y: logo.scale.y / 1.2,
              z: logo.scale.z / 1.2,
              duration: 800,
              easing: 'easeOutElastic(1, 0.5)',
              complete: () => {
                if (onComplete) onComplete();
              }
            });

            this._trackAnimation('logo', bounceAnim);
          } else if (onComplete) {
            onComplete();
          }
        }
      }));
    }
  }

  /**
   * Animate logo entrance (when first loaded)
   * @param {THREE.Group} logo - The 3D logo object
   * @param {Function} onComplete - Callback when animation completes
   */
  animateLogoEntrance(logo, onComplete = null) {
    if (!logo) return null;

    console.log('[AnimationManager] Animating logo entrance');
    this.clearAnimations('logo');

    // Store original scale
    const originalScale = logo.scale.x;

    // Start with tiny scale and full rotation
    logo.scale.set(0.01, 0.01, 0.01);
    logo.rotation.y = Math.PI * 2;

    // Scale up with elastic effect
    const scaleAnim = anime({
      targets: logo.scale,
      x: originalScale,
      y: originalScale,
      z: originalScale,
      duration: 1500,
      easing: 'easeOutElastic(1, 0.5)'
    });

    // Rotate to default position
    const rotateAnim = anime({
      targets: logo.rotation,
      y: 0,
      duration: 1500,
      easing: 'easeOutQuad',
      complete: () => {
        if (onComplete) onComplete();
      }
    });

    this._trackAnimation('logo', scaleAnim);
    return this._trackAnimation('logo', rotateAnim);
  }

  /**
   * Reset logo to initial state without animation
   * @param {THREE.Group} logo - The 3D logo object
   * @param {Object} initialState - Initial values {position, rotation}
   */
  resetLogoState(logo, initialState) {
    if (!logo || !initialState) return;

    console.log('[AnimationManager] Resetting logo state immediately');
    this.clearAnimations('logo');

    // Cancel any existing animations
    anime.remove(logo.position);
    anime.remove(logo.rotation);
    anime.remove(logo.scale);

    // Reset to initial values
    if (initialState.position) {
      logo.position.copy(initialState.position);
    }

    if (initialState.rotation) {
      logo.rotation.copy(initialState.rotation);
    }
  }

  /**
   * Create fade overlay for transitions
   * @param {string} direction - 'in' or 'out'
   * @param {Function} onComplete - Callback when animation completes
   */
  createTransitionOverlay(direction = 'in', onComplete = null) {
    console.log(`[AnimationManager] Creating ${direction} transition overlay`);

    // Create overlay element
    const overlay = document.createElement('div');
    overlay.classList.add('page-transition-overlay');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      pointer-events: none;
      opacity: ${direction === 'in' ? '0.8' : '0'};
      transition: opacity 0.4s ease;
    `;

    document.body.appendChild(overlay);

    // Animate overlay
    if (direction === 'in') {
      // Already visible, fade out
      setTimeout(() => {
        overlay.style.opacity = '0';

        // Remove after transition
        setTimeout(() => {
          overlay.remove();
          if (onComplete) onComplete();
        }, 400);
      }, 10);
    } else {
      // Fade in
      requestAnimationFrame(() => {
        overlay.style.opacity = '0.8';

        // Remove after transition
        setTimeout(() => {
          overlay.remove();
          if (onComplete) onComplete();
        }, 400);
      });
    }
  }

  /**
   * Add ripple effect to element
   * @param {HTMLElement} element - Target element
   */
  addRippleEffect(element) {
    if (!element) return;

    // Create ripple element
    const ripple = document.createElement('div');
    ripple.classList.add('menu-ripple');
    ripple.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(100,149,237,0.3) 0%, transparent 70%);
      pointer-events: none;
      z-index: -1;
    `;

    element.appendChild(ripple);

    // Animate ripple expansion
    setTimeout(() => {
      ripple.style.transition = 'transform 1s cubic-bezier(0.19, 1, 0.22, 1)';
      ripple.style.transform = 'translate(-50%, -50%) scale(50)';

      // Remove after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 1000);
    }, 10);
  }
}

// Export a singleton instance
export const AnimationManager = new AnimationManagerClass();

================
File: src/utils/AppState.js
================
/**
 * AppState.js
 * Centralized state management for the entire application
 */
import { UIManager } from './UIManager';
import { AnimationManager } from './AnimationManager';

// Define all possible app states
const APP_STATES = {
  INITIALIZING: 'INITIALIZING',    // Initial loading state
  IDLE: 'IDLE',                    // Home page with logo, continue prompt visible
  MENU_OPENING: 'MENU_OPENING',    // During menu opening animation
  MENU_OPEN: 'MENU_OPEN',          // Menu is visible
  MENU_CLOSING: 'MENU_CLOSING',    // During menu closing animation
  TRANSITIONING_TO_SUBPAGE: 'TRANSITIONING_TO_SUBPAGE',  // Navigating to subpage
  TRANSITIONING_TO_HOME: 'TRANSITIONING_TO_HOME',        // Navigating to home
  SUBPAGE: 'SUBPAGE'               // On a subpage
};

class AppStateManager {
  constructor() {
    this._currentState = APP_STATES.INITIALIZING;
    this._previousState = null;
    this._lastStateChangeTime = 0;
    this._navigationBackToHome = false;
    this._stateDebounceTime = 300; // ms to prevent rapid state changes
    this._stateChangeCallbacks = new Map();

    // Debug mode for logging state changes
    this._debugMode = false;
  }

  /**
   * Get the current application state
   */
  get currentState() {
    return this._currentState;
  }

  /**
   * Set debug mode on/off
   */
  setDebugMode(enabled) {
    this._debugMode = !!enabled;
    this._log(`Debug mode ${this._debugMode ? 'enabled' : 'disabled'}`);
  }

  /**
   * Check if we're currently transitioning between states
   */
  get isTransitioning() {
    return [
      APP_STATES.MENU_OPENING,
      APP_STATES.MENU_CLOSING,
      APP_STATES.TRANSITIONING_TO_SUBPAGE,
      APP_STATES.TRANSITIONING_TO_HOME
    ].includes(this._currentState);
  }

  /**
   * Get the scene instance if available
   */
  get sceneInstance() {
    return window.sceneInstance || null;
  }

  /**
   * Initialize the AppState with the correct initial state based on URL
   */
  initialize() {
    // Determine initial state based on URL
    this._currentState = this.isHomePage() ? APP_STATES.INITIALIZING : APP_STATES.SUBPAGE;

    this._log(`Initialized with state: ${this._currentState}`);

    // Listen for Astro page transitions
    document.addEventListener('astro:before-preparation', this.handleBeforePreparation.bind(this));
    document.addEventListener('astro:before-navigation', this.handleBeforeNavigation.bind(this));
    document.addEventListener('astro:after-navigation', this.handleAfterNavigation.bind(this));
    document.addEventListener('astro:page-load', this.handlePageLoad.bind(this));

    // Initialize UI manager
    UIManager.initialize();

    // Move to IDLE state after initialization if on home page
    if (this.isHomePage() && this._currentState === APP_STATES.INITIALIZING) {
      // Small delay to allow scene setup
      setTimeout(() => {
        this.transitionTo(APP_STATES.IDLE);
      }, 200);
    }
  }

  /**
   * Register callback for a specific state change
   * @param {string} fromState - State to transition from (or '*' for any)
   * @param {string} toState - State to transition to (or '*' for any)
   * @param {Function} callback - Function to call when transition occurs
   * @returns {string} Unique ID for unregistering
   */
  onStateChange(fromState, toState, callback) {
    const id = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this._stateChangeCallbacks.set(id, { fromState, toState, callback });
    return id;
  }

  /**
   * Unregister a state change callback
   * @param {string} id - ID returned from onStateChange
   */
  offStateChange(id) {
    if (this._stateChangeCallbacks.has(id)) {
      this._stateChangeCallbacks.delete(id);
      return true;
    }
    return false;
  }

  /**
   * Transition to a new state with appropriate actions
   * @param {string} newState - Target state from APP_STATES
   * @returns {boolean} Success of transition
   */
  transitionTo(newState) {
    // Prevent rapid state changes
    const now = Date.now();
    if (now - this._lastStateChangeTime < this._stateDebounceTime) {
      this._log(`State transition debounced: ${this._currentState} â†’ ${newState}`);
      return false;
    }

    // Validate state
    if (!Object.values(APP_STATES).includes(newState)) {
      console.error(`Invalid state: ${newState}`);
      return false;
    }

    this._log(`State transition: ${this._currentState} â†’ ${newState}`);
    this._previousState = this._currentState;
    this._currentState = newState;
    this._lastStateChangeTime = now;

    // Perform state-specific actions
    this.performStateActions(newState, this._previousState);

    // Dispatch custom event
    document.dispatchEvent(new CustomEvent('appStateChanged', {
      detail: {
        newState,
        previousState: this._previousState
      }
    }));

    // Execute registered callbacks
    this._stateChangeCallbacks.forEach(({ fromState, toState, callback }) => {
      if ((fromState === '*' || fromState === this._previousState) &&
          (toState === '*' || toState === newState)) {
        callback(newState, this._previousState);
      }
    });

    return true;
  }

  /**
   * Check if we're on the home page
   */
  isHomePage() {
    return window.location.pathname === '/' || window.location.pathname === '';
  }

  /**
   * Check if menu interaction is allowed
   */
  isMenuInteractionAllowed() {
    return this.isHomePage() && !this.isTransitioning;
  }

  /**
   * Flag that we're navigating back to home
   */
  setNavigatingBackToHome(value) {
    this._navigationBackToHome = value;
    this._log(`Navigating back to home: ${value}`);
  }

  /**
   * Check if we're navigating back to home
   */
  isNavigatingBackToHome() {
    return this._navigationBackToHome;
  }

  /**
   * Reset transition state in the 3D scene
   */
  resetSceneTransitionState() {
    if (this.sceneInstance && typeof this.sceneInstance.resetTransitionState === 'function') {
      this._log('Resetting scene transition state');
      this.sceneInstance.resetTransitionState();
    }
  }

  /**
   * Open the menu with animations
   */
  openMenu() {
    if (!this.isMenuInteractionAllowed()) {
      this._log('Menu interaction not allowed');
      return false;
    }

    if (this._currentState === APP_STATES.IDLE) {
      // Transition to opening state
      if (!this.transitionTo(APP_STATES.MENU_OPENING)) {
        return false;
      }

      const menu = document.getElementById('menu');
      const prompt = document.getElementById('continue-prompt');

      // Hide continue prompt
      if (prompt) {
        AnimationManager.animateContinuePromptOut(prompt);
      }

      // Apply distortion effect
      AnimationManager.animateDistortion(0.1, 2000, 'menuOpen');

      // Animate logo if it exists
      if (this.sceneInstance && this.sceneInstance.logo) {
        AnimationManager.animateLogoForMenuOpen(this.sceneInstance.logo, () => {
          // When logo animation completes, show menu
          if (menu) {
            AnimationManager.animateMenuIn(menu, () => {
              this.transitionTo(APP_STATES.MENU_OPEN);
            });
          } else {
            this.transitionTo(APP_STATES.MENU_OPEN);
          }
        });
      } else {
        // No logo, just show menu
        if (menu) {
          AnimationManager.animateMenuIn(menu, () => {
            this.transitionTo(APP_STATES.MENU_OPEN);
          });
        } else {
          this.transitionTo(APP_STATES.MENU_OPEN);
        }
      }

      return true;
    }

    return false;
  }

  /**
   * Close the menu with animations
   */
  closeMenu() {
    if (this._currentState !== APP_STATES.MENU_OPEN) {
      this._log('Cannot close menu: not in MENU_OPEN state');
      return false;
    }

    // Transition to closing state
    if (!this.transitionTo(APP_STATES.MENU_CLOSING)) {
      return false;
    }

    const menu = document.getElementById('menu');

    // Apply distortion effect
    AnimationManager.animateDistortion(0.15, 1500, 'menuClose');

    // Animate menu out
    if (menu) {
      AnimationManager.animateMenuOut(menu);
    }

    // Animate logo if it exists and we're on home page
    if (this.sceneInstance && this.sceneInstance.logo && this.isHomePage()) {
      const initialState = {
        position: this.sceneInstance.initialLogoPosition,
        rotation: this.sceneInstance.initialLogoRotation
      };

      AnimationManager.animateLogoForMenuClose(this.sceneInstance.logo, initialState, () => {
        this.transitionTo(APP_STATES.IDLE);

        // Show continue prompt when menu is closed
        const prompt = document.getElementById('continue-prompt');
        if (prompt) {
          AnimationManager.animateContinuePromptIn(prompt);
        }
      });
    } else {
      // No logo animation, just complete transition
      setTimeout(() => {
        this.transitionTo(APP_STATES.IDLE);

        // Show continue prompt when menu is closed if on home page
        if (this.isHomePage()) {
          const prompt = document.getElementById('continue-prompt');
          if (prompt) {
            AnimationManager.animateContinuePromptIn(prompt);
          }
        }
      }, 500);
    }

    return true;
  }

  /**
   * Prepare for transition between pages
   */
  prepareForTransition(toHomePage) {
    // Set state based on direction
    this.transitionTo(toHomePage ? APP_STATES.TRANSITIONING_TO_HOME : APP_STATES.TRANSITIONING_TO_SUBPAGE);

    // Flag for back-to-home navigation
    if (toHomePage) {
      this.setNavigatingBackToHome(true);
    }

    // Prepare the scene for transition
    if (this.sceneInstance && typeof this.sceneInstance.prepareForTransition === 'function') {
      this.sceneInstance.prepareForTransition();
    }

    // Create transition overlay effect
    AnimationManager.createTransitionOverlay('out');
  }

  /**
   * Handle actions specific to each state
   */
  performStateActions(newState, previousState) {
    // Clear any existing animations for clean state
    AnimationManager.clearAnimations();

    // Perform specific actions for each state
    switch (newState) {
      case APP_STATES.INITIALIZING:
        // Initial state, no specific actions needed
        break;

      case APP_STATES.IDLE:
        UIManager.ensureMenuHidden();
        if (this.isHomePage()) {
          UIManager.showContinuePrompt();
        }
        break;

      case APP_STATES.MENU_OPEN:
        UIManager.hideContinuePrompt();
        UIManager.ensureMenuVisible();
        break;

      case APP_STATES.MENU_OPENING:
      case APP_STATES.MENU_CLOSING:
        // Transition states, animations handled elsewhere
        break;

      case APP_STATES.TRANSITIONING_TO_SUBPAGE:
      case APP_STATES.TRANSITIONING_TO_HOME:
        // Transition states, animations handled elsewhere
        break;

      case APP_STATES.SUBPAGE:
        UIManager.hideContinuePrompt();
        UIManager.ensureMenuHidden();
        break;
    }
  }

  /**
   * Event Handlers for Astro page transitions
   */
  handleBeforePreparation(e) {
    this._log('Before preparation, navigating to:', e.to);

    // Detect navigation direction
    const isNavigatingToHome = e.to === '/' || e.to.endsWith('/');
    const isLeavingHomePage = this.isHomePage();

    if (isNavigatingToHome && !isLeavingHomePage) {
      this.prepareForTransition(true);
    } else if (isLeavingHomePage) {
      this.prepareForTransition(false);
    }
  }

  handleBeforeNavigation(e) {
    this._log('Before navigation');

    // Additional preparation before navigation starts
    if (this.isTransitioning) {
      // Make sure any animations are in a stable state
      AnimationManager.clearAnimations();
    }
  }

  handleAfterNavigation() {
    this._log('After navigation');

    // Create entrance transition effect
    AnimationManager.createTransitionOverlay('in');

    // Update state based on new URL
    if (this.isHomePage()) {
      // Reset scene state when arriving at home
      this.resetSceneTransitionState();

      // If we came from a subpage, ensure we're in IDLE state
      if (this._currentState === APP_STATES.TRANSITIONING_TO_HOME) {
        this.transitionTo(APP_STATES.IDLE);
      }
    } else {
      // We're on a subpage
      this.transitionTo(APP_STATES.SUBPAGE);
    }
  }

  handlePageLoad() {
    this._log('Page load');

    if (this.isHomePage()) {
      // Reset scene state
      this.resetSceneTransitionState();

      // Check if we navigated back to home
      if (this.isNavigatingBackToHome()) {
        this.setNavigatingBackToHome(false);

        // Special handling for back-to-home navigation
        if (this.sceneInstance && typeof this.sceneInstance.handleReturnToHome === 'function') {
          this.sceneInstance.handleReturnToHome();
        }

        this.transitionTo(APP_STATES.IDLE);
        UIManager.enforceCorrectUIState();
      }
    }
  }

  /**
   * Conditional logging
   */
  _log(...args) {
    if (this._debugMode) {
      console.log('[AppState]', ...args);
    }
  }
}

// Export APP_STATES enum for external use
export { APP_STATES };

// Export a singleton instance
export const AppState = new AppStateManager();

================
File: src/utils/EventHandler.js
================
/**
 * EventHandler.js
 * Completely fixed version that works with the provided AnimationManager
 */
import * as THREE from 'three';
import { APP_STATES } from './AppState';

// Simple helper function to check if we're on the home page
function isHomePage() {
  return window.location.pathname === '/' || window.location.pathname === '';
}

class EventHandlerClass {
  constructor() {
    // Event handling state
    this._initialized = false;
    this._boundHandlers = {};
    this._eventListeners = [];

    // Debug mode for detailed logging
    this._debugMode = true;

    // Make instance globally available
    if (typeof window !== 'undefined') {
      window.EventHandler = this;
    }
  }

  /**
   * Initialize all event listeners
   */
  initialize() {
    // Prevent double initialization
    if (this._initialized) {
      this._log('Already initialized, cleaning up first');
      this.cleanup();
    }

    console.log('Initializing event handlers');
    this._initialized = true;

    // Create bound handler functions to maintain context
    this._bindHandlers();

    // Register global event listeners
    this._addListener(document, 'keydown', this._boundHandlers.keydown);
    this._addListener(document, 'keydown', this._boundHandlers.escape);

    // Set up scene click detection for logo
    const sceneContainer = document.getElementById('scene-container');
    if (sceneContainer) {
      console.log('Adding click handler to scene container');

      // Remove any existing handlers first
      sceneContainer.removeEventListener('click', this._boundHandlers.logoClick);

      // Add with capture to ensure we get the event first
      sceneContainer.addEventListener('click', this._boundHandlers.logoClick, true);

      // Store in our tracking array
      this._eventListeners.push({
        element: sceneContainer,
        eventType: 'click',
        handler: this._boundHandlers.logoClick
      });
    }

    // Handle menu background clicks
    const menu = document.getElementById('menu');
    if (menu) {
      this._addListener(menu, 'click', this._boundHandlers.menuBgClick);
    }

    // Handle menu item clicks specifically
    const menuItems = document.querySelectorAll('.menu nav ul li a:not(.strike)');
    menuItems.forEach(item => {
      this._addListener(item, 'click', this._boundHandlers.menuItemClick);
    });

    // Initialize back button
    this.initializeBackButton();

    // Add direct click handler on logo as backup
    this._setupDirectLogoClickHandler();

    console.log('Event handlers initialized - all click handlers ready');
  }

  /**
   * Set up a direct click handler on the center area as a backup
   */
  _setupDirectLogoClickHandler() {
    const sceneContainer = document.getElementById('scene-container');
    if (!sceneContainer) return;

    // Create an overlay for the center area
    let centerOverlay = document.getElementById('logo-click-overlay');

    // If it already exists, remove it
    if (centerOverlay) {
      centerOverlay.remove();
    }

    // Create a new overlay
    centerOverlay = document.createElement('div');
    centerOverlay.id = 'logo-click-overlay';
    centerOverlay.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      cursor: pointer;
      z-index: 10;
      opacity: 0;
    `;

    document.body.appendChild(centerOverlay);

    // Add click handler
    centerOverlay.addEventListener('click', (e) => {
      console.log('Center overlay clicked');
      this.handleLogoClick(e);
    });

    this._eventListeners.push({
      element: centerOverlay,
      eventType: 'click',
      handler: this.handleLogoClick.bind(this)
    });
  }

  /**
   * Bind event handler methods to maintain 'this' context
   */
  _bindHandlers() {
    this._boundHandlers = {
      keydown: this.handleKeyDown.bind(this),
      escape: this.handleEscapeKey.bind(this),
      logoClick: this.handleLogoClick.bind(this),
      menuBgClick: this.handleMenuBackgroundClick.bind(this),
      menuItemClick: this.handleMenuItemClick.bind(this),
      backButton: this.handleBackButtonClick.bind(this)
    };
  }

  /**
   * Add event listener with tracking for cleanup
   */
  _addListener(element, eventType, handler, options) {
    if (!element) return;

    element.addEventListener(eventType, handler, options);
    this._eventListeners.push({ element, eventType, handler });

    return { element, eventType, handler };
  }

  /**
   * Remove a specific event listener
   */
  _removeListener(listener) {
    if (!listener || !listener.element) return false;

    listener.element.removeEventListener(listener.eventType, listener.handler);
    return true;
  }

  /**
   * Initialize back button
   */
  initializeBackButton() {
    // Find back button
    const backButton = document.getElementById('back-to-home');
    if (backButton) {
      console.log('Initializing back button');

      // Remove existing listeners to prevent duplicates
      const newBackButton = backButton.cloneNode(true);
      if (backButton.parentNode) {
        backButton.parentNode.replaceChild(newBackButton, backButton);
      }

      // Add new listener
      this._addListener(newBackButton, 'click', this._boundHandlers.backButton);
    }
  }

  /**
   * Clean up all event listeners
   */
  cleanup() {
    console.log(`Cleaning up ${this._eventListeners.length} event handlers`);

    // Remove all registered event listeners
    this._eventListeners.forEach(listener => {
      this._removeListener(listener);
    });

    this._eventListeners = [];
    this._initialized = false;
  }

  /**
   * Handle space key press to trigger menu
   */
  handleKeyDown(e) {
    if (e.code === 'Space' && isHomePage()) {
      console.log('Space key pressed, handling continue');
      this.triggerContinueAction();

      // Prevent space from scrolling the page
      e.preventDefault();
    }
  }

  /**
   * Handle logo clicks via raycasting
   */
  handleLogoClick(e) {
    if (!isHomePage()) return;

    console.log('Scene container click detected');

    const scene = window.sceneInstance;
    if (!scene) {
      console.log('Scene not ready');
      return;
    }

    // Center of the screen
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // Check if the click is near the center (where the logo is)
    const distanceFromCenter = Math.sqrt(
      Math.pow(e.clientX - centerX, 2) +
      Math.pow(e.clientY - centerY, 2)
    );

    // Logo click is detected if:
    // 1. Click is within 150px of center or
    // 2. Raycasting hits the logo (if logo and camera are available)
    let logoClicked = distanceFromCenter < 150;

    // Try raycasting if logo and camera are available
    if (scene.logo && scene.camera) {
      // Set up raycaster for logo detection
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1
      );

      raycaster.setFromCamera(mouse, scene.camera);
      const intersects = raycaster.intersectObject(scene.logo, true);

      if (intersects.length > 0) {
        logoClicked = true;
        console.log('Logo hit by raycaster');
      }
    }

    if (logoClicked) {
      console.log('Logo click detected - triggering continue');
      this.triggerContinueAction();
      e.preventDefault();
      e.stopPropagation();
    }
  }

  /**
   * Trigger the continue action (menu opening)
   */
  triggerContinueAction() {
    // Try using Scene's handleContinue first
    if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
      window.sceneInstance.handleContinue();
      return;
    }

    // Try using AppState as fallback
    if (window.AppState && typeof window.AppState.openMenu === 'function') {
      window.AppState.openMenu();
      return;
    }

    console.warn('No method found to handle continue action');
  }

  /**
   * Handle menu background clicks to close menu
   */
  handleMenuBackgroundClick(e) {
    // Only if clicked directly on menu background, not its children
    if (e.target === e.currentTarget) {
      console.log('Menu background click detected');
      this.closeMenu();
    }
  }

  /**
   * Handle menu item clicks
   */
  handleMenuItemClick(e) {
    console.log('Menu item clicked');

    const href = e.currentTarget.getAttribute('href');

    // Only handle animation for navigation within site
    // (not for external links or anchors)
    if (href && !href.startsWith('http') && !href.startsWith('#')) {
      console.log('Internal navigation detected, closing menu');

      // Get the scene instance
      const scene = window.sceneInstance;
      if (scene && typeof scene.animateMenuAway === 'function') {
        scene.animateMenuAway();
      } else {
        // Fallback to manual closing
        this.closeMenu();
      }
    }
  }

  /**
   * Close the menu
   */
  closeMenu() {
    // Try using Scene's closeMenu first
    if (window.sceneInstance && typeof window.sceneInstance.closeMenu === 'function') {
      window.sceneInstance.closeMenu();
      return;
    }

    // Try using AppState as fallback
    if (window.AppState && typeof window.AppState.closeMenu === 'function') {
      window.AppState.closeMenu();
      return;
    }

    // Direct manipulation as last resort
    const menu = document.getElementById('menu');
    if (menu) {
      menu.classList.remove('visible');
      menu.classList.add('hidden');
    }
  }

  /**
   * Handle escape key to close menu
   */
  handleEscapeKey(e) {
    if (e.code === 'Escape') {
      console.log('Escape key pressed');
      this.closeMenu();
    }
  }

  /**
   * Handle back button clicks
   */
  handleBackButtonClick(e) {
    // If already on home page, just trigger menu
    if (isHomePage()) {
      e.preventDefault();
      this.triggerContinueAction();
    } else {
      // On subpage, apply transition effect
      this.triggerCustomTransition();
      window.navBackToHome = true;
    }
  }

  /**
   * Create a custom transition overlay effect
   */
  triggerCustomTransition() {
    console.log('Triggering custom transition effect');

    // Use AnimationManager if available
    if (window.AnimationManager && typeof window.AnimationManager.createTransitionOverlay === 'function') {
      window.AnimationManager.createTransitionOverlay('out');
      return;
    }

    // Fallback - create overlay manually
    const overlay = document.createElement('div');
    overlay.classList.add('page-transition-overlay');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease;
    `;

    document.body.appendChild(overlay);

    // Fade in overlay
    requestAnimationFrame(() => {
      overlay.style.opacity = '0.8';
    });

    // Clean up overlay after navigation
    setTimeout(() => {
      overlay.remove();
    }, 800);
  }

  /**
   * Conditional logging
   */
  _log(...args) {
    if (this._debugMode) {
      console.log('[EventHandler]', ...args);
    }
  }
}

// Export a singleton instance
export const EventHandler = new EventHandlerClass();

================
File: src/utils/menuState.js
================
/**
 * menuState.js - Compatibility Layer
 * 
 * This version preserves the old API while adding compatibility with the new system
 */

// Ensure we have the global navigation flag
if (typeof window !== 'undefined') {
  window.navBackToHome = window.navBackToHome || false;
}

/**
 * Checks if current page is a subpage (not home)
 * @returns {boolean} true if on a subpage
 */
function isSubPage() {
  return window.location.pathname !== '/' && window.location.pathname !== '';
}

/**
 * Checks if menu interaction should be allowed
 * Only allowed on home page
 * @returns {boolean} true if menu interaction is allowed
 */
function isMenuInteractionAllowed() {
  return !isSubPage();
}

/**
 * Shows the menu with enhanced animation
 * This is a direct DOM manipulation with advanced animations
 */
export function showMenu() {
  // Now delegates to Scene.handleContinue() if available
  if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
    window.sceneInstance.handleContinue();
    return true;
  }
  
  // Fallback to direct DOM manipulation
  if (isSubPage()) {
    console.log('Menu not shown - on subpage');
    return false;
  }

  const menu = document.getElementById('menu');
  const continuePrompt = document.getElementById('continue-prompt');
  
  if (menu) {
    menu.classList.remove('hidden');
    menu.classList.add('visible');
    
    if (continuePrompt) {
      continuePrompt.classList.add('hidden');
    }
    
    return true;
  }
  return false;
}

/**
 * Hides the menu with enhanced animation
 */
export function hideMenu() {
  // Delegate to Scene.closeMenu() if available
  if (window.sceneInstance && typeof window.sceneInstance.closeMenu === 'function') {
    window.sceneInstance.closeMenu();
    return true;
  }
  
  // Fallback to direct DOM manipulation
  const menu = document.getElementById('menu');
  
  if (menu) {
    menu.classList.remove('visible');
    setTimeout(() => {
      menu.classList.add('hidden');
    }, 500);
    
    const continuePrompt = document.getElementById('continue-prompt');
    if (continuePrompt && (window.location.pathname === '/' || window.location.pathname === '')) {
      continuePrompt.classList.remove('hidden');
    }
    
    return true;
  }
  return false;
}

/**
 * Initializes the back button with custom view transition
 */
export function initializeBackButton() {
  // Delegate to EventHandler if available
  if (typeof EventHandler !== 'undefined' && EventHandler.initializeBackButton) {
    EventHandler.initializeBackButton();
    return;
  }
  
  // Fallback implementation
  const backButton = document.getElementById('back-to-home');
  if (backButton) {
    backButton.addEventListener('click', (event) => {
      if (!isSubPage()) {
        event.preventDefault();
        showMenu();
      } else {
        window.navBackToHome = true;
      }
    });
  }
}

/**
 * Function to be called on home page load to prepare the menu
 */
export function setupHomePage() {
  if (!isSubPage()) {
    const continuePrompt = document.getElementById('continue-prompt');
    const menu = document.getElementById('menu');
    
    // Check for back navigation
    if (window.navBackToHome) {
      if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
        setTimeout(() => {
          window.sceneInstance.handleContinue();
          window.navBackToHome = false;
        }, 200);
      }
    } else if (menu && !menu.classList.contains('visible') && continuePrompt) {
      continuePrompt.classList.remove('hidden');
    }
  }
}

/**
 * Handle user interaction (space key or logo click)
 */
export function handleUserTrigger() {
  if (!isMenuInteractionAllowed()) return false;
  
  // Delegate to Scene.handleContinue if available
  if (window.sceneInstance && typeof window.sceneInstance.handleContinue === 'function') {
    window.sceneInstance.handleContinue();
    return true;
  }
  
  return showMenu();
}

/**
 * Enforce the correct state of the continue prompt
 */
export function enforceContinuePromptState() {
  const menu = document.getElementById('menu');
  const continuePrompt = document.getElementById('continue-prompt');
  
  if (!menu || !continuePrompt) return;
  
  // If menu is visible, ensure prompt is hidden
  if (menu.classList.contains('visible')) {
    continuePrompt.classList.add('hidden');
  } else if (window.location.pathname === '/' || window.location.pathname === '') {
    // If on home page and menu is not visible, ensure prompt is shown
    continuePrompt.classList.remove('hidden');
  }
  
  console.log('Enforced continue prompt state');
}

// Export the helper functions
export { isMenuInteractionAllowed };

================
File: src/utils/UIManager.js
================
/**
 * UIManager.js
 * Handles all direct DOM manipulations for the application
 * Provides a clean interface for UI operations while avoiding state management
 */
import { APP_STATES } from './AppState';

class UIManagerClass {
  constructor() {
    // Element cache to avoid repeated DOM queries
    this._elements = {
      menu: null,
      continuePrompt: null,
      loadingScreen: null,
      sceneContainer: null,
      homeContent: null
    };

    // Track last UI enforcement time to prevent flicker
    this._lastEnforcementTime = 0;

    // Debug mode
    this._debugMode = false;

    // Make this instance globally available
    if (typeof window !== 'undefined') {
      window.UIManager = this;
    }
  }

  /**
   * Set debug mode on/off
   */
  setDebugMode(enabled) {
    this._debugMode = !!enabled;
    this._log(`Debug mode ${this._debugMode ? 'enabled' : 'disabled'}`);
  }

  /**
   * Get animation manager if available
   */
  get animationManager() {
    return window.AnimationManager || null;
  }

  /**
   * Initialize and cache DOM elements
   */
  initialize() {
    this._elements = {
      menu: document.getElementById('menu'),
      continuePrompt: document.getElementById('continue-prompt'),
      loadingScreen: document.getElementById('loading-screen'),
      sceneContainer: document.getElementById('scene-container'),
      homeContent: document.querySelector('.home-content')
    };

    this._log('UI elements cached');

    // Apply any needed initial styles
    this._fixInitialStyles();
  }

  /**
   * Fix any initial style issues when page loads
   */
  _fixInitialStyles() {
    // Ensure menu has no leftover inline styles
    if (this._elements.menu) {
      this._elements.menu.style.opacity = '';

      const menuItems = this._elements.menu.querySelectorAll('nav ul li');
      menuItems.forEach(item => {
        item.style.opacity = '';
        item.style.transform = '';
      });
    }
  }

  /**
   * Get a cached DOM element or query for it if not cached
   */
  getElement(key) {
    if (!this._elements[key]) {
      this._elements[key] = document.getElementById(key) || document.querySelector(`.${key}`);
    }
    return this._elements[key];
  }

  /**
   * Show the menu immediately (without animation)
   */
  ensureMenuVisible() {
    const menu = this.getElement('menu');
    if (!menu) return;

    menu.classList.remove('hidden');
    menu.classList.add('visible');
    menu.style.opacity = '';

    // Also make home content visible if it exists
    const homeContent = this.getElement('homeContent');
    if (homeContent) {
      homeContent.style.opacity = '1';
    }

    this._log('Menu visibility enforced');
  }

  /**
   * Hide the menu immediately (without animation)
   */
  ensureMenuHidden() {
    const menu = this.getElement('menu');
    if (!menu) return;

    menu.classList.remove('visible');
    menu.classList.add('hidden');
    menu.style.opacity = '';

    // Reset menu items
    const menuItems = menu.querySelectorAll('nav ul li');
    menuItems.forEach(item => {
      item.style.opacity = '';
      item.style.transform = '';
    });

    this._log('Menu hidden state enforced');
  }

  /**
   * Show the continue prompt with animation
   */
  showContinuePrompt() {
    const prompt = this.getElement('continuePrompt');
    if (!prompt) return;

    this._log('Showing continue prompt');

    if (this.animationManager) {
      this.animationManager.animateContinuePromptIn(prompt);
    } else {
      // Simple fallback if AnimationManager not available
      prompt.classList.remove('hidden');
      prompt.style.opacity = '1';
    }
  }

  /**
   * Hide the continue prompt
   */
  hideContinuePrompt() {
    const prompt = this.getElement('continuePrompt');
    if (!prompt) return;

    this._log('Hiding continue prompt');

    if (this.animationManager) {
      this.animationManager.animateContinuePromptOut(prompt);
    } else {
      // Simple fallback if AnimationManager not available
      prompt.style.opacity = '0';
      setTimeout(() => {
        prompt.classList.add('hidden');
      }, 600);
    }
  }

  /**
   * Hide the loading screen
   */
  hideLoadingScreen() {
    const loadingScreen = this.getElement('loadingScreen');
    if (!loadingScreen) return;

    this._log('Hiding loading screen');
    loadingScreen.style.opacity = '0';

    setTimeout(() => {
      loadingScreen.style.display = 'none';
    }, 500);
  }

  /**
   * Show the home content
   */
  showHomeContent() {
    const homeContent = this.getElement('homeContent');
    if (!homeContent) return;

    homeContent.style.opacity = '1';
  }

  /**
   * Hide the home content
   */
  hideHomeContent() {
    const homeContent = this.getElement('homeContent');
    if (!homeContent) return;

    homeContent.style.opacity = '0';
  }

  /**
   * Enforce correct UI state based on App State
   * Acts as a recovery mechanism for when state gets out of sync
   */
  enforceCorrectUIState(appState) {
    // Don't run too frequently to prevent flickering
    const now = Date.now();
    if (now - this._lastEnforcementTime < 300) return;
    this._lastEnforcementTime = now;

    if (!appState) {
      this._log('Cannot enforce UI state: AppState required');
      return;
    }

    this._log('Enforcing correct UI state for', appState.currentState);

    const menu = this.getElement('menu');
    const continuePrompt = this.getElement('continuePrompt');
    const homeContent = this.getElement('homeContent');

    if (!menu || !continuePrompt) return;

    // Fix menu item styles to ensure they're ready for animation
    const menuItems = menu.querySelectorAll('nav ul li');

    // Enforce correct UI based on app state
    switch (appState.currentState) {
      case APP_STATES.IDLE:
        // Should show continue prompt, hide menu
        if (continuePrompt.classList.contains('hidden')) {
          continuePrompt.classList.remove('hidden');
          continuePrompt.style.opacity = '1';
        }

        if (menu.classList.contains('visible')) {
          this.ensureMenuHidden();
        }

        if (homeContent) {
          homeContent.style.opacity = '0';
        }
        break;

      case APP_STATES.MENU_OPEN:
        // Should hide continue prompt, show menu
        if (!continuePrompt.classList.contains('hidden')) {
          continuePrompt.classList.add('hidden');
          continuePrompt.style.opacity = '0';
        }

        if (!menu.classList.contains('visible')) {
          this.ensureMenuVisible();

          // Ensure menu items are visible and in correct position
          menuItems.forEach(item => {
            item.style.opacity = '1';
            item.style.transform = 'translateY(0)';
          });
        }

        if (homeContent) {
          homeContent.style.opacity = '1';
        }
        break;

      case APP_STATES.SUBPAGE:
        // On subpage, ensure menu is hidden and prompt is hidden
        if (!continuePrompt.classList.contains('hidden')) {
          continuePrompt.classList.add('hidden');
        }

        if (menu.classList.contains('visible')) {
          this.ensureMenuHidden();
        }
        break;

      default:
        // For transition states, don't enforce changes to avoid conflicts
        // with ongoing animations
        break;
    }
  }

  /**
   * Handle page transition effects
   */
  handlePageTransition(isLeavingPage, isHomePage) {
    if (isLeavingPage) {
      // Leaving current page
      this._log(`Transitioning away from ${isHomePage ? 'home' : 'subpage'}`);

      // Fade out content
      const content = isHomePage ? this.getElement('homeContent') : document.querySelector('.photos-container');

      if (content) {
        content.style.opacity = '0';
      }
    } else {
      // Entering new page
      this._log(`Transitioning to ${isHomePage ? 'home' : 'subpage'}`);

      // Fade in content with delay to allow for scene transition
      const content = isHomePage ? this.getElement('homeContent') : document.querySelector('.photos-container');

      if (content) {
        // Reset opacity first
        content.style.opacity = '0';

        // Trigger fade in with delay
        setTimeout(() => {
          content.style.opacity = '1';
        }, 200);
      }
    }
  }

  /**
   * Conditional logging
   */
  _log(...args) {
    if (this._debugMode) {
      console.log('[UIManager]', ...args);
    }
  }
}

// Export a singleton instance
export const UIManager = new UIManagerClass();

================
File: tailwind.config.js
================
const plugin = require('tailwindcss/plugin');
const postcss = require('postcss');
const postcssJs = require('postcss-js');

const clampGenerator = require('./src/css-utils/clamp-generator.js');
const tokensToTailwind = require('./src/css-utils/tokens-to-tailwind.js');

// Raw design tokens
const colorTokens = require('./src/design-tokens/colors.json');
const fontTokens = require('./src/design-tokens/fonts.json');
const spacingTokens = require('./src/design-tokens/spacing.json');
const textSizeTokens = require('./src/design-tokens/text-sizes.json');
const textLeadingTokens = require('./src/design-tokens/text-leading.json');
const textWeightTokens = require('./src/design-tokens/text-weights.json');
const viewportTokens = require('./src/design-tokens/viewports.json');

// Process design tokens
const colors = tokensToTailwind(colorTokens.items);
const fontFamily = tokensToTailwind(fontTokens.items);
const fontWeight = tokensToTailwind(textWeightTokens.items);
const fontSize = tokensToTailwind(clampGenerator(textSizeTokens.items));
const lineHeight = tokensToTailwind(textLeadingTokens.items);
const spacing = tokensToTailwind(clampGenerator(spacingTokens.items));

module.exports = {
  content: ['./src/**/*.{html,js,jsx,mdx,njk,twig,vue}'],
  // Add color classes to safe list so they are always generated
  safelist: [],
  presets: [],
  theme: {
    screens: {
      sm: `${viewportTokens.min}px`,
      md: `${viewportTokens.mid}px`,
      lg: `${viewportTokens.max}px`
    },
    colors,
    spacing,
    fontSize,
    lineHeight,
    fontFamily,
    fontWeight,
    backgroundColor: ({theme}) => theme('colors'),
    textColor: ({theme}) => theme('colors'),
    margin: ({theme}) => ({
      auto: 'auto',
      ...theme('spacing')
    }),
    padding: ({theme}) => theme('spacing')
  },
  variantOrder: [
    'first',
    'last',
    'odd',
    'even',
    'visited',
    'checked',
    'empty',
    'read-only',
    'group-hover',
    'group-focus',
    'focus-within',
    'hover',
    'focus',
    'focus-visible',
    'active',
    'disabled'
  ],

  // Disables Tailwind's reset and usage of rgb/opacity
  corePlugins: {
    preflight: false,
    textOpacity: false,
    backgroundOpacity: false,
    borderOpacity: false
  },

  // Prevents Tailwind's core components
  blocklist: ['container'],

  // Prevents Tailwind from generating that wall of empty custom properties 
  experimental: {
    optimizeUniversalDefaults: true
  },

  plugins: [
    // Generates custom property values from tailwind config
    plugin(function ({addComponents, config}) {
      let result = '';

      const currentConfig = config();

      const groups = [
        {key: 'colors', prefix: 'color'},
        {key: 'spacing', prefix: 'space'},
        {key: 'fontSize', prefix: 'size'},
        {key: 'lineHeight', prefix: 'leading'},
        {key: 'fontFamily', prefix: 'font'},
        {key: 'fontWeight', prefix: 'font'}
      ];

      groups.forEach(({key, prefix}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          result += `--${prefix}-${key}: ${group[key]};`;
        });
      });

      addComponents({
        ':root': postcssJs.objectify(postcss.parse(result))
      });
    }),

    // Generates custom utility classes
    plugin(function ({addUtilities, config}) {
      const currentConfig = config();
      const customUtilities = [
        {key: 'spacing', prefix: 'flow-space', property: '--flow-space'},
        {key: 'spacing', prefix: 'region-space', property: '--region-space'},
        {key: 'spacing', prefix: 'gutter', property: '--gutter'}
      ];

      customUtilities.forEach(({key, prefix, property}) => {
        const group = currentConfig.theme[key];

        if (!group) {
          return;
        }

        Object.keys(group).forEach(key => {
          addUtilities({
            [`.${prefix}-${key}`]: postcssJs.objectify(
              postcss.parse(`${property}: ${group[key]}`)
            )
          });
        });
      });
    })
  ]
};

================
File: tsconfig.json
================
{
  "extends": "astro/tsconfigs/strict",
  "exclude": ["./dist"]
}
